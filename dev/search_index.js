var documenterSearchIndex = {"docs":
[{"location":"Base/Numbers/#Numbers","page":"Numbers","title":"Numbers","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"using AbstractTrees\nAbstractTrees.children(t::Type) =\n    filter(t->isdefined(Base, Symbol(t)) || isdefined(Core, Symbol(t)), subtypes(t))\nprint_tree(Number)","category":"page"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Number\n├─ Complex\n└─ Real\n   ├─ AbstractFloat\n   │  ├─ BigFloat\n   │  ├─ Float16\n   │  ├─ Float32\n   │  └─ Float64\n   ├─ AbstractIrrational\n   │  └─ Irrational\n   ├─ Integer\n   │  ├─ Bool\n   │  ├─ Signed\n   │  │  ├─ BigInt\n   │  │  ├─ Int128\n   │  │  ├─ Int16\n   │  │  ├─ Int32\n   │  │  ├─ Int64\n   │  │  └─ Int8\n   │  └─ Unsigned\n   │     ├─ UInt128\n   │     ├─ UInt16\n   │     ├─ UInt32\n   │     ├─ UInt64\n   │     └─ UInt8\n   └─ Rational","category":"page"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Core.Number\nCore.Real","category":"page"},{"location":"Base/Numbers/#Core.Number","page":"Numbers","title":"Core.Number","text":"Number\n\nAbstract supertype for all number types.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Real","page":"Numbers","title":"Core.Real","text":"Real <: Number\n\nAbstract supertype for all real numbers.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Integer-types","page":"Numbers","title":"Integer types","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Core.Integer\nCore.Bool\nCore.Unsigned\nCore.UInt8\nCore.UInt16\nCore.UInt32\nCore.UInt64\nCore.UInt128\nCore.Signed\nCore.Int8\nCore.Int16\nCore.Int32\nCore.Int64\nCore.Int128\nBase.BigInt","category":"page"},{"location":"Base/Numbers/#Core.Integer","page":"Numbers","title":"Core.Integer","text":"Integer <: Real\n\nAbstract supertype for all integers (e.g. Signed, Unsigned, and Bool).\n\nSee also isinteger, trunc, div.\n\nExamples\n\njulia> 42 isa Integer\ntrue\n\njulia> 1.0 isa Integer\nfalse\n\njulia> isinteger(1.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Bool","page":"Numbers","title":"Core.Bool","text":"Bool <: Integer\n\nBoolean type, containing the values true and false.\n\nBool is a kind of number: false is numerically equal to 0 and true is numerically equal to 1. Moreover, false acts as a multiplicative \"strong zero\" against NaN and Inf:\n\njulia> [true, false] == [1, 0]\ntrue\n\njulia> 42.0 + true\n43.0\n\njulia> 0 .* (NaN, Inf, -Inf)\n(NaN, NaN, NaN)\n\njulia> false .* (NaN, Inf, -Inf)\n(0.0, 0.0, -0.0)\n\nBranches via if and other conditionals only accept Bool. There are no \"truthy\" values in Julia.\n\nComparisons typically return Bool, and broadcasted comparisons may return BitArray instead of an Array{Bool}.\n\njulia> [1 2 3 4 5] .< pi\n1×5 BitMatrix:\n 1  1  1  0  0\n\njulia> map(>(pi), [1 2 3 4 5])\n1×5 Matrix{Bool}:\n 0  0  0  1  1\n\nSee also trues, falses, ifelse.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Unsigned","page":"Numbers","title":"Core.Unsigned","text":"Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\nBuilt-in unsigned integers are printed in hexadecimal, with prefix 0x, and can be entered in the same way.\n\nExamples\n\njulia> typemax(UInt8)\n0xff\n\njulia> Int(0x00d)\n13\n\njulia> unsigned(true)\n0x0000000000000001\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.UInt8","page":"Numbers","title":"Core.UInt8","text":"UInt8 <: Unsigned <: Integer\n\n8-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x07 == 7.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.UInt16","page":"Numbers","title":"Core.UInt16","text":"UInt16 <: Unsigned <: Integer\n\n16-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x000f == 15.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.UInt32","page":"Numbers","title":"Core.UInt32","text":"UInt32 <: Unsigned <: Integer\n\n32-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x0000001f == 31.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.UInt64","page":"Numbers","title":"Core.UInt64","text":"UInt64 <: Unsigned <: Integer\n\n64-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x000000000000003f == 63.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.UInt128","page":"Numbers","title":"Core.UInt128","text":"UInt128 <: Unsigned <: Integer\n\n128-bit unsigned integer type.\n\nPrinted in hexadecimal, thus 0x0000000000000000000000000000007f == 127.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Signed","page":"Numbers","title":"Core.Signed","text":"Signed <: Integer\n\nAbstract supertype for all signed integers.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Int8","page":"Numbers","title":"Core.Int8","text":"Int8 <: Signed <: Integer\n\n8-bit signed integer type.\n\nRepresents numbers n ∈ -128:127. Note that such integers overflow without warning, thus typemax(Int8) + Int8(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Int16","page":"Numbers","title":"Core.Int16","text":"Int16 <: Signed <: Integer\n\n16-bit signed integer type.\n\nRepresents numbers n ∈ -32768:32767. Note that such integers overflow without warning, thus typemax(Int16) + Int16(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Int32","page":"Numbers","title":"Core.Int32","text":"Int32 <: Signed <: Integer\n\n32-bit signed integer type.\n\nNote that such integers overflow without warning, thus typemax(Int32) + Int32(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Int64","page":"Numbers","title":"Core.Int64","text":"Int64 <: Signed <: Integer\n\n64-bit signed integer type.\n\nNote that such integers overflow without warning, thus typemax(Int64) + Int64(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Int128","page":"Numbers","title":"Core.Int128","text":"Int128 <: Signed <: Integer\n\n128-bit signed integer type.\n\nNote that such integers overflow without warning, thus typemax(Int128) + Int128(1) < 0.\n\nSee also Int, widen, BigInt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.GMP.BigInt","page":"Numbers","title":"Base.GMP.BigInt","text":"BigInt <: Signed\n\nArbitrary precision integer type.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Floating-point-types","page":"Numbers","title":"Floating-point types","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Core.AbstractFloat\nCore.Float16\nCore.Float32\nCore.Float64\nBase.BigFloat","category":"page"},{"location":"Base/Numbers/#Core.AbstractFloat","page":"Numbers","title":"Core.AbstractFloat","text":"AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Float16","page":"Numbers","title":"Core.Float16","text":"Float16 <: AbstractFloat <: Real\n\n16-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 5 exponent, 10 fraction bits.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Float32","page":"Numbers","title":"Core.Float32","text":"Float32 <: AbstractFloat <: Real\n\n32-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 8 exponent, 23 fraction bits.\n\nThe exponent for scientific notation should be entered as lower-case f, thus 2f3 === 2.0f0 * 10^3 === Float32(2_000). For array literals and comprehensions, the element type can be specified before the square brackets: Float32[1,4,9] == Float32[i^2 for i in 1:3].\n\nSee also Inf32, NaN32, Float16, exponent, frexp.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Core.Float64","page":"Numbers","title":"Core.Float64","text":"Float64 <: AbstractFloat <: Real\n\n64-bit floating point number type (IEEE 754 standard). Binary format is 1 sign, 11 exponent, 52 fraction bits. See bitstring, signbit, exponent, frexp, and significand to access various bits.\n\nThis is the default for floating point literals, 1.0 isa Float64, and for many operations such as 1/2, 2pi, log(2), range(0,90,length=4). Unlike integers, this default does not change with Sys.WORD_SIZE.\n\nThe exponent for scientific notation can be entered as e or E, thus 2e3 === 2.0E3 === 2.0 * 10^3. Doing so is strongly preferred over 10^n because integers overflow, thus 2.0 * 10^19 < 0 but 2e19 > 0.\n\nSee also Inf, NaN, floatmax, Float32, Complex.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.MPFR.BigFloat","page":"Numbers","title":"Base.MPFR.BigFloat","text":"BigFloat <: AbstractFloat\n\nArbitrary precision floating point number type.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Irrational","page":"Numbers","title":"Irrational","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Base.AbstractIrrational\nBase.Irrational","category":"page"},{"location":"Base/Numbers/#Base.AbstractIrrational","page":"Numbers","title":"Base.AbstractIrrational","text":"AbstractIrrational <: Real\n\nNumber type representing an exact irrational value, which is automatically rounded to the correct precision in arithmetic operations with other numeric quantities.\n\nSubtypes MyIrrational <: AbstractIrrational should implement at least ==(::MyIrrational, ::MyIrrational), hash(x::MyIrrational, h::UInt), and convert(::Type{F}, x::MyIrrational) where {F <: Union{BigFloat,Float32,Float64}}.\n\nIf a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents √n for integers n will give a rational result when n is a perfect square), then it should also implement isinteger, iszero, isone, and == with Real values (since all of these default to false for AbstractIrrational types), as well as defining hash to equal that of the corresponding Rational.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.Irrational","page":"Numbers","title":"Base.Irrational","text":"Irrational{sym} <: AbstractIrrational\n\nNumber type representing an exact irrational value denoted by the symbol sym, such as π, ℯ and γ.\n\nSee also AbstractIrrational.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Rational","page":"Numbers","title":"Rational","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Base.Rational","category":"page"},{"location":"Base/Numbers/#Base.Rational","page":"Numbers","title":"Base.Rational","text":"Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T. Rationals are checked for overflow.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Complex-types","page":"Numbers","title":"Complex types","text":"","category":"section"},{"location":"Base/Numbers/","page":"Numbers","title":"Numbers","text":"Base.Complex\nBase.ComplexF16\nBase.ComplexF32\nBase.ComplexF64","category":"page"},{"location":"Base/Numbers/#Base.Complex","page":"Numbers","title":"Base.Complex","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\nSee also: Real, complex, real.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.ComplexF16","page":"Numbers","title":"Base.ComplexF16","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\nSee also: Real, complex, real.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.ComplexF32","page":"Numbers","title":"Base.ComplexF32","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\nSee also: Real, complex, real.\n\n\n\n\n\n","category":"type"},{"location":"Base/Numbers/#Base.ComplexF64","page":"Numbers","title":"Base.ComplexF64","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\nSee also: Real, complex, real.\n\n\n\n\n\n","category":"type"},{"location":"ElementaryMath/Exp-and-Log/Logarithms/#Logarithms","page":"Logarithms","title":"Logarithms","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/Logarithms/","page":"Logarithms","title":"Logarithms","text":"Base.log2\nBase.log10\nBase.log1p","category":"page"},{"location":"ElementaryMath/Exp-and-Log/Logarithms/#Base.log2","page":"Logarithms","title":"Base.log2","text":"log2(x)\n\nCompute the logarithm of x to base 2. Throws DomainError for negative Real arguments.\n\nSee also: exp2, ldexp, ispow2.\n\nExamples\n\njulia> log2(4)\n2.0\n\njulia> log2(10)\n3.321928094887362\n\njulia> log2(-2)\nERROR: DomainError with -2.0:\nlog2 was called with a negative real argument but will only return a complex result if called with a complex argument. Try log2(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31\n[...]\n\njulia> log2.(2.0 .^ (-1:1))\n3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Logarithms/#Base.log10","page":"Logarithms","title":"Base.log10","text":"log10(x)\n\nCompute the logarithm of x to base 10. Throws DomainError for negative Real arguments.\n\nExamples\n\njulia> log10(100)\n2.0\n\njulia> log10(2)\n0.3010299956639812\n\njulia> log10(-2)\nERROR: DomainError with -2.0:\nlog10 was called with a negative real argument but will only return a complex result if called with a complex argument. Try log10(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Logarithms/#Base.log1p","page":"Logarithms","title":"Base.log1p","text":"log1p(x)\n\nAccurate natural logarithm of 1+x. Throws DomainError for Real arguments less than -1.\n\nExamples\n\njulia> log1p(-0.5)\n-0.6931471805599453\n\njulia> log1p(0)\n0.0\n\njulia> log1p(-2)\nERROR: DomainError with -2.0:\nlog1p was called with a real argument < -1 but will only return a complex result if called with a complex argument. Try log1p(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/acosh/#acosh","page":"acosh","title":"acosh","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acosh/","page":"acosh","title":"acosh","text":"Base.acosh","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acosh/#Base.acosh","page":"acosh","title":"Base.acosh","text":"acosh(x)\n\nCompute the inverse hyperbolic cosine of x.\n\n\n\n\n\nacosh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix cosine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_4].\n\n[AH16_4]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/cosc/#cosc","page":"cosc","title":"cosc","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cosc/","page":"cosc","title":"cosc","text":"Base.cosc","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cosc/#Base.Math.cosc","page":"cosc","title":"Base.Math.cosc","text":"cosc(x)\n\nCompute cos(pi x)  x - sin(pi x)  (pi x^2) if x neq 0, and 0 if x = 0. This is the derivative of sinc(x).\n\nSee also sinc.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/asin/#asin","page":"asin","title":"asin","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/asin/","page":"asin","title":"asin","text":"Base.asin","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/asin/#Base.asin","page":"asin","title":"Base.asin","text":"asin(x)\n\nCompute the inverse sine of x, where the output is in radians.\n\nSee also asind for output in degrees.\n\nExamples\n\njulia> asin.((0, 1/2, 1))\n(0.0, 0.5235987755982989, 1.5707963267948966)\n\njulia> asind.((0, 1/2, 1))\n(0.0, 30.000000000000004, 90.0)\n\n\n\n\n\nasin(A::AbstractMatrix)\n\nCompute the inverse matrix sine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_2].\n\n[AH16_2]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> asin(sin([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5-4.16334e-17im  0.1-5.55112e-17im\n -0.2+9.71445e-17im  0.3-1.249e-16im\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Bit-Wise-Operations","page":"Bit-Wise Operations","title":"Bit-Wise Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/BitWise/","page":"Bit-Wise Operations","title":"Bit-Wise Operations","text":"~\n&\n|\nxor\n⊻","category":"page"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:~","page":"Bit-Wise Operations","title":"Base.:~","text":"~(x)\n\nBitwise not.\n\nSee also: !, &, |.\n\nExamples\n\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:&","page":"Bit-Wise Operations","title":"Base.:&","text":"x & y\n\nBitwise and. Implements three-valued logic, returning missing if one operand is missing and the other is true. Add parentheses for function application form: (&)(x, y).\n\nSee also: |, xor, &&.\n\nExamples\n\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\njulia> true & missing\nmissing\n\njulia> false & missing\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:|","page":"Bit-Wise Operations","title":"Base.:|","text":"x | y\n\nBitwise or. Implements three-valued logic, returning missing if one operand is missing and the other is false.\n\nSee also: &, xor, ||.\n\nExamples\n\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\njulia> true | missing\ntrue\n\njulia> false | missing\nmissing\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.xor","page":"Bit-Wise Operations","title":"Base.xor","text":"xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y. Implements three-valued logic, returning missing if one of the arguments is missing.\n\nThe infix operation a ⊻ b is a synonym for xor(a,b), and ⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\nExamples\n\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitVector:\n 0\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:⊻","page":"Bit-Wise Operations","title":"Base.:⊻","text":"xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y. Implements three-valued logic, returning missing if one of the arguments is missing.\n\nThe infix operation a ⊻ b is a synonym for xor(a,b), and ⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\nExamples\n\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitVector:\n 0\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Shift","page":"Bit-Wise Operations","title":"Shift","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/BitWise/","page":"Bit-Wise Operations","title":"Bit-Wise Operations","text":"<<\n>> \n>>>","category":"page"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:<<","page":"Bit-Wise Operations","title":"Base.:<<","text":"<<(x, n)\n\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left by n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0, this is equivalent to x >> -n.\n\nExamples\n\njulia> Int8(3) << 2\n12\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> bitstring(Int8(12))\n\"00001100\"\n\nSee also >>, >>>, exp2, ldexp.\n\n\n\n\n\n<<(B::BitVector, n) -> BitVector\n\nLeft bit shift operator, B << n. For n >= 0, the result is B with elements shifted n positions backwards, filling with false values. If n < 0, elements are shifted forwards. Equivalent to B >> -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B << 1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\njulia> B << -1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:>>","page":"Bit-Wise Operations","title":"Base.:>>","text":">>(x, n)\n\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted right by n bits, filling with 0s if x >= 0, 1s if x < 0, preserving the sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is equivalent to x << -n.\n\nExamples\n\njulia> Int8(13) >> 2\n3\n\njulia> bitstring(Int8(13))\n\"00001101\"\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(-4))\n\"11111100\"\n\nSee also >>>, <<.\n\n\n\n\n\n>>(B::BitVector, n) -> BitVector\n\nRight bit shift operator, B >> n. For n >= 0, the result is B with elements shifted n positions forward, filling with false values. If n < 0, elements are shifted backwards. Equivalent to B << -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B >> 1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\njulia> B >> -1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/BitWise/#Base.:>>>","page":"Bit-Wise Operations","title":"Base.:>>>","text":">>>(x, n)\n\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x shifted right by n bits, filling with 0s. For n < 0, this is equivalent to x << -n.\n\nFor Unsigned integer types, this is equivalent to >>. For Signed integer types, this is equivalent to signed(unsigned(x) >> n).\n\nExamples\n\njulia> Int8(-14) >>> 2\n60\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(60))\n\"00111100\"\n\nBigInts are treated as if having infinite size, so no filling is required and this is equivalent to >>.\n\nSee also >>, <<.\n\n\n\n\n\n>>>(B::BitVector, n) -> BitVector\n\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for details and examples.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/#Function-Index","page":"Function Index","title":"Function Index","text":"","category":"section"},{"location":"ElementaryMath/","page":"Function Index","title":"Function Index","text":"NOTE: This list is auto-generated.","category":"page"},{"location":"ElementaryMath/","page":"Function Index","title":"Function Index","text":"","category":"page"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Discrete-Math","page":"Discrete Math","title":"Discrete Math","text":"","category":"section"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/","page":"Discrete Math","title":"Discrete Math","text":"factorial\ngcd\ngcdx\nlcm\nbinomial\nfactorial","category":"page"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Rational","page":"Discrete Math","title":"Rational","text":"","category":"section"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/","page":"Discrete Math","title":"Discrete Math","text":"Rational\nrationalize\nnumerator\ndenominator","category":"page"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#index","page":"Discrete Math","title":"index","text":"","category":"section"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/","page":"Discrete Math","title":"Discrete Math","text":"Base.factorial\nBase.gcd\nBase.gcdx\nBase.lcm\nBase.binomial\n\nBase.rationalize\nBase.numerator\nBase.denominator","category":"page"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.factorial","page":"Discrete Math","title":"Base.factorial","text":"factorial(n::Integer)\n\nFactorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n)) to compute the result exactly in arbitrary precision.\n\nSee also binomial.\n\nExamples\n\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead\nStacktrace:\n[...]\n\njulia> factorial(big(21))\n51090942171709440000\n\nExternal links\n\nFactorial on Wikipedia.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.gcd","page":"Discrete Math","title":"Base.gcd","text":"gcd(x, y...)\n\nGreatest common (positive) divisor (or zero if all arguments are zero). The arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> gcd(6, 9)\n3\n\njulia> gcd(6, -9)\n3\n\njulia> gcd(6, 0)\n6\n\njulia> gcd(0, 0)\n0\n\njulia> gcd(1//3, 2//3)\n1//3\n\njulia> gcd(1//3, -2//3)\n1//3\n\njulia> gcd(1//3, 2)\n1//3\n\njulia> gcd(0, 0, 10, 15)\n5\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.gcdx","page":"Discrete Math","title":"Base.gcdx","text":"gcdx(a, b)\n\nComputes the greatest common (positive) divisor of a and b and their Bézout coefficients, i.e. the integer coefficients u and v that satisfy ua+vb = d = gcd(a b). gcdx(a b) returns (d u v).\n\nThe arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n\nnote: Note\nBézout coefficients are not uniquely defined. gcdx returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients u and v are minimal in the sense that u  bd and v  ad. Furthermore, the signs of u and v are chosen so that d is positive. For unsigned integers, the coefficients u and v might be near their typemax, and the identity then holds only via the unsigned integers' modulo arithmetic.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.lcm","page":"Discrete Math","title":"Base.lcm","text":"lcm(x, y...)\n\nLeast common (positive) multiple (or zero if any argument is zero). The arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> lcm(2, 3)\n6\n\njulia> lcm(-2, 3)\n6\n\njulia> lcm(0, 3)\n0\n\njulia> lcm(0, 0)\n0\n\njulia> lcm(1//3, 2//3)\n2//3\n\njulia> lcm(1//3, -2//3)\n2//3\n\njulia> lcm(1//3, 2)\n2//1\n\njulia> lcm(1, 3, 5, 7)\n105\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.binomial","page":"Discrete Math","title":"Base.binomial","text":"binomial(n::Integer, k::Integer)\n\nThe binomial coefficient binomnk, being the coefficient of the kth term in the polynomial expansion of (1+x)^n.\n\nIf n is non-negative, then it is the number of ways to choose k out of n items:\n\nbinomnk = fracnk (n-k)\n\nwhere n is the factorial function.\n\nIf n is negative, then it is defined in terms of the identity\n\nbinomnk = (-1)^k binomk-n-1k\n\nSee also factorial.\n\nExamples\n\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\njulia> binomial(-5, 3)\n-35\n\nExternal links\n\nBinomial coefficient on Wikipedia.\n\n\n\n\n\nbinomial(x::Number, k::Integer)\n\nThe generalized binomial coefficient, defined for k ≥ 0 by the polynomial\n\nfrac1k prod_j=0^k-1 (x - j)\n\nWhen k < 0 it returns zero.\n\nFor the case of integer x, this is equivalent to the ordinary integer binomial coefficient\n\nbinomnk = fracnk (n-k)\n\nFurther generalizations to non-integer k are mathematically possible, but involve the Gamma function and/or the beta function, which are not provided by the Julia standard library but are available in external packages such as SpecialFunctions.jl.\n\nExternal links\n\nBinomial coefficient on Wikipedia.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.rationalize","page":"Discrete Math","title":"Base.rationalize","text":"rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number x as a Rational number with components of the given integer type. The result will differ from x by no more than tol.\n\nExamples\n\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.numerator","page":"Discrete Math","title":"Base.numerator","text":"numerator(x)\n\nNumerator of the rational representation of x.\n\nExamples\n\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/DiscreteMath/DiscreteMath/#Base.denominator","page":"Discrete Math","title":"Base.denominator","text":"denominator(x)\n\nDenominator of the rational representation of x.\n\nExamples\n\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/SinCos/sincosd/#sincosd","page":"sincosd","title":"sincosd","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/SinCos/sincosd/","page":"sincosd","title":"sincosd","text":"Base.sincosd","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/sincosd/#Base.Math.sincosd","page":"sincosd","title":"Base.Math.sincosd","text":"sincosd(x)\n\nSimultaneously compute the sine and cosine of x, where x is in degrees.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/asind/#asind","page":"asind","title":"asind","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/asind/","page":"asind","title":"asind","text":"Base.asind","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/asind/#Base.Math.asind","page":"asind","title":"Base.Math.asind","text":"asind(x)\n\nCompute the inverse sine of x, where the output is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Modulo-Division-and-Rounding","page":"Modulo Division and Rounding","title":"Modulo Division and Rounding","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/","page":"Modulo Division and Rounding","title":"Modulo Division and Rounding","text":"mod\nmod1\ninvmod\nrem\nBase.div\nBase.:÷\ndivrem\nfld\nfld1\nfldmod\nfldmod1\ncld\nceil\nfloor\nround","category":"page"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.mod","page":"Modulo Division and Rounding","title":"Base.mod","text":"mod(x::Integer, r::AbstractUnitRange)\n\nFind y in the range r such that x  y (mod n), where n = length(r), i.e. y = mod(x - first(r), n) + first(r).\n\nSee also mod1.\n\nExamples\n\njulia> mod(0, Base.OneTo(3))  # mod1(0, 3)\n3\n\njulia> mod(3, 0:2)  # mod(3, 3)\n0\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\n\n\n\n\nmod(x, y)\nrem(x, y, RoundDown)\n\nThe reduction of x modulo y, or equivalently, the remainder of x after floored division by y, i.e. x - y*fld(x,y) if computed without intermediate rounding.\n\nThe result will have the same sign as y, and magnitude less than abs(y) (with some exceptions, see note below).\n\nnote: Note\nWhen used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to y, then it may be rounded to y.\n\nSee also: rem, div, fld, mod1, invmod.\n\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n\njulia> mod.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n 1  2  0  1  2  0  1  2  0  1  2\n\n\n\n\n\nrem(x::Integer, T::Type{<:Integer}) -> T\nmod(x::Integer, T::Type{<:Integer}) -> T\n%(x::Integer, T::Type{<:Integer}) -> T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\n\nExamples\n\njulia> x = 129 % Int8\n-127\n\njulia> typeof(x)\nInt8\n\njulia> x = 129 % BigInt\n129\n\njulia> typeof(x)\nBigInt\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.mod1","page":"Modulo Division and Rounding","title":"Base.mod1","text":"mod1(x, y)\n\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y) in the range (0 y for positive y and in the range y0) for negative y.\n\nWith integer arguments and positive y, this is equal to mod(x, 1:y), and hence natural for 1-based indexing. By comparison, mod(x, y) == mod(x, 0:y-1) is natural for computations with offsets or strides.\n\nSee also mod, fld1, fldmod1.\n\nExamples\n\njulia> mod1(4, 2)\n2\n\njulia> mod1.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n 1  2  3  1  2  3  1  2  3  1  2\n\njulia> mod1.([-0.1, 0, 0.1, 1, 2, 2.9, 3, 3.1]', 3)\n1×8 Matrix{Float64}:\n 2.9  3.0  0.1  1.0  2.0  2.9  3.0  0.1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.invmod","page":"Modulo Division and Rounding","title":"Base.invmod","text":"invmod(n::Integer, m::Integer)\n\nTake the inverse of n modulo m: y such that n y = 1 pmod m, and div(ym) = 0. This will throw an error if m = 0, or if gcd(nm) neq 1.\n\nExamples\n\njulia> invmod(2, 5)\n3\n\njulia> invmod(2, 3)\n2\n\njulia> invmod(5, 6)\n5\n\n\n\n\n\ninvmod(n::Integer, T) where {T <: Base.BitInteger}\ninvmod(n::T) where {T <: Base.BitInteger}\n\nCompute the modular inverse of n in the integer ring of type T, i.e. modulo 2^N where N = 8*sizeof(T) (e.g. N = 32 for Int32). In other words these methods satisfy the following identities:\n\nn * invmod(n) == 1\n(n * invmod(n, T)) % T == 1\n(n % T) * invmod(n, T) == 1\n\nNote that * here is modular multiplication in the integer ring, T.\n\nSpecifying the modulus implied by an integer type as an explicit value is often inconvenient since the modulus is by definition too big to be represented by the type.\n\nThe modular inverse is computed much more efficiently than the general case using the algorithm described in https://arxiv.org/pdf/2204.04342.pdf.\n\ncompat: Julia 1.11\nThe invmod(n) and invmod(n, T) methods require Julia 1.11 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.rem","page":"Modulo Division and Rounding","title":"Base.rem","text":"rem(x, y)\n%(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in magnitude than y. This value is always exact.\n\nSee also: div, mod, mod1, divrem.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\njulia> rem.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -2  -1  0  -2  -1  0  1  2  0  1  2\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.div","page":"Modulo Division and Rounding","title":"Base.div","text":"div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean (integer) division. Generally equivalent to a mathematical operation x/y without a fractional part.\n\nSee also: cld, fld, rem, divrem.\n\nExamples\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\njulia> 5.0 ÷ 2\n2.0\n\njulia> div.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -1  -1  -1  0  0  0  0  0  1  1  1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.:÷","page":"Modulo Division and Rounding","title":"Base.:÷","text":"div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean (integer) division. Generally equivalent to a mathematical operation x/y without a fractional part.\n\nSee also: cld, fld, rem, divrem.\n\nExamples\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\njulia> 5.0 ÷ 2\n2.0\n\njulia> div.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -1  -1  -1  0  0  0  0  0  1  1  1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.divrem","page":"Modulo Division and Rounding","title":"Base.divrem","text":"divrem(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient and remainder from Euclidean division. Equivalent to (div(x, y, r), rem(x, y, r)). Equivalently, with the default value of r, this call is equivalent to (x ÷ y, x % y).\n\nSee also: fldmod, cld.\n\nExamples\n\njulia> divrem(3, 7)\n(0, 3)\n\njulia> divrem(7, 3)\n(2, 1)\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.fld","page":"Modulo Division and Rounding","title":"Base.fld","text":"fld(x, y)\n\nLargest integer less than or equal to x / y. Equivalent to div(x, y, RoundDown).\n\nSee also div, cld, fld1.\n\nExamples\n\njulia> fld(7.3, 5.5)\n1.0\n\njulia> fld.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -2  -2  -1  -1  -1  0  0  0  1  1  1\n\nBecause fld(x, y) implements strictly correct floored rounding based on the true value of floating-point numbers, unintuitive situations can arise. For example:\n\njulia> fld(6.0, 0.1)\n59.0\njulia> 6.0 / 0.1\n60.0\njulia> 6.0 / big(0.1)\n59.99999999999999666933092612453056361837965690217069245739573412231113406246995\n\nWhat is happening here is that the true value of the floating-point number written as 0.1 is slightly larger than the numerical value 1/10 while 6.0 represents the number 6 precisely. Therefore the true value of 6.0 / 0.1 is slightly less than 60. When doing division, this is rounded to precisely 60.0, but fld(6.0, 0.1) always takes the floor of the true value, so the result is 59.0.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.fld1","page":"Modulo Division and Rounding","title":"Base.fld1","text":"fld1(x, y)\n\nFlooring division, returning a value consistent with mod1(x,y)\n\nSee also mod1, fldmod1.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.fldmod","page":"Modulo Division and Rounding","title":"Base.fldmod","text":"fldmod(x, y)\n\nThe floored quotient and modulus after division. A convenience wrapper for divrem(x, y, RoundDown). Equivalent to (fld(x, y), mod(x, y)).\n\nSee also: fld, cld, fldmod1.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.fldmod1","page":"Modulo Division and Rounding","title":"Base.fldmod1","text":"fldmod1(x, y)\n\nReturn (fld1(x,y), mod1(x,y)).\n\nSee also fld1, mod1.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.cld","page":"Modulo Division and Rounding","title":"Base.cld","text":"cld(x, y)\n\nSmallest integer larger than or equal to x / y. Equivalent to div(x, y, RoundUp).\n\nSee also div, fld.\n\nExamples\n\njulia> cld(5.5, 2.2)\n3.0\n\njulia> cld.(-5:5, 3)'\n1×11 adjoint(::Vector{Int64}) with eltype Int64:\n -1  -1  -1  0  0  0  1  1  1  2  2\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.ceil","page":"Modulo Division and Rounding","title":"Base.ceil","text":"ceil([T,] x)\nceil(x; digits::Integer= [, base = 10])\nceil(x; sigdigits::Integer= [, base = 10])\n\nceil(x) returns the nearest integral value of the same type as x that is greater than or equal to x.\n\nceil(T, x) converts the result to type T, throwing an InexactError if the ceiled value is not representable as a T.\n\nKeywords digits, sigdigits and base work as for round.\n\nTo support ceil for a new type, define Base.round(x::NewType, ::RoundingMode{:Up}).\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.floor","page":"Modulo Division and Rounding","title":"Base.floor","text":"floor([T,] x)\nfloor(x; digits::Integer= [, base = 10])\nfloor(x; sigdigits::Integer= [, base = 10])\n\nfloor(x) returns the nearest integral value of the same type as x that is less than or equal to x.\n\nfloor(T, x) converts the result to type T, throwing an InexactError if the floored value is not representable a T.\n\nKeywords digits, sigdigits and base work as for round.\n\nTo support floor for a new type, define Base.round(x::NewType, ::RoundingMode{:Down}).\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.round","page":"Modulo Division and Rounding","title":"Base.round","text":"round([T,] x, [r::RoundingMode])\nround(x, [r::RoundingMode]; digits::Integer=0, base = 10)\nround(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\n\nRounds the number x.\n\nWithout keyword arguments, x is rounded to an integer value, returning a value of type T, or of the same type of x if no T is provided. An InexactError will be thrown if the value is not representable by T, similar to convert.\n\nIf the digits keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base base.\n\nIf the sigdigits keyword argument is provided, it rounds to the specified number of significant digits, in base base.\n\nThe RoundingMode r controls the direction of the rounding; the default is RoundNearest, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that round may give incorrect results if the global rounding mode is changed (see rounding).\n\nWhen rounding to a floating point type, will round to integers representable by that type (and Inf) rather than true integers. Inf is treated as one ulp greater than the floatmax(T) for purposes of determining \"nearest\", similar to convert.\n\nExamples\n\njulia> round(1.7)\n2.0\n\njulia> round(Int, 1.7)\n2\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(pi; digits=2)\n3.14\n\njulia> round(pi; digits=3, base=2)\n3.125\n\njulia> round(123.456; sigdigits=2)\n120.0\n\njulia> round(357.913; sigdigits=4, base=2)\n352.0\n\njulia> round(Float16, typemax(UInt128))\nInf16\n\njulia> floor(Float16, typemax(UInt128))\nFloat16(6.55e4)\n\nnote: Note\nRounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the Float64 value represented by 1.15 is actually less than 1.15, yet will be rounded to 1.2. For example:julia> x = 1.15\n1.15\n\njulia> big(1.15)\n1.149999999999999911182158029987476766109466552734375\n\njulia> x < 115//100\ntrue\n\njulia> round(x, digits=1)\n1.2\n\nExtensions\n\nTo extend round to new numeric types, it is typically sufficient to define Base.round(x::NewType, r::RoundingMode).\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Roungding","page":"Modulo Division and Rounding","title":"Roungding","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/","page":"Modulo Division and Rounding","title":"Modulo Division and Rounding","text":"rounding\nsetrounding","category":"page"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.rounding","page":"Modulo Division and Rounding","title":"Base.Rounding.rounding","text":"rounding(T)\n\nGet the current floating point rounding mode for type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion.\n\nSee RoundingMode for available modes.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.setrounding","page":"Modulo Division and Rounding","title":"Base.Rounding.setrounding","text":"setrounding(T, mode)\n\nSet the rounding mode of floating point type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default RoundNearest.\n\nNote that this is currently only supported for T == BigFloat.\n\nwarning: Warning\nThis function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.\n\n\n\n\n\nsetrounding(f::Function, T, mode)\n\nChange the rounding mode of floating point type T for the duration of f. It is logically equivalent to:\n\nold = rounding(T)\nsetrounding(T, mode)\nf()\nsetrounding(T, old)\n\nSee RoundingMode for available rounding modes.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#RoundingMode","page":"Modulo Division and Rounding","title":"RoundingMode","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/","page":"Modulo Division and Rounding","title":"Modulo Division and Rounding","text":"RoundingMode\nRoundNearest\nRoundNearestTiesAway\nRoundNearestTiesUp\nRoundToZero\nRoundFromZero\nRoundUp\nRoundDown","category":"page"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundingMode","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundingMode","text":"RoundingMode\n\nA type used for controlling the rounding mode of floating point operations (via rounding/setrounding functions), or as optional arguments for rounding to the nearest integer (via the round function).\n\nCurrently supported rounding modes are:\n\nRoundNearest (default)\nRoundNearestTiesAway\nRoundNearestTiesUp\nRoundToZero\nRoundFromZero\nRoundUp\nRoundDown\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9. Prior versions support RoundFromZero for BigFloats only.\n\n\n\n\n\n","category":"type"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundNearest","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundNearest","text":"RoundNearest\n\nThe default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundNearestTiesAway","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundNearestTiesAway","text":"RoundNearestTiesAway\n\nRounds to nearest integer, with ties rounded away from zero (C/C++ round behaviour).\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundNearestTiesUp","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundNearestTiesUp","text":"RoundNearestTiesUp\n\nRounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript round behaviour).\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundToZero","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundToZero","text":"RoundToZero\n\nround using this rounding mode is an alias for trunc.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundFromZero","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundFromZero","text":"RoundFromZero\n\nRounds away from zero.\n\ncompat: Julia 1.9\nRoundFromZero requires at least Julia 1.9. Prior versions support RoundFromZero for BigFloats only.\n\nExamples\n\njulia> BigFloat(\"1.0000000000000001\", 5, RoundFromZero)\n1.06\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundUp","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundUp","text":"RoundUp\n\nround using this rounding mode is an alias for ceil.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Arithmetic/Modulo-and-Round/#Base.Rounding.RoundDown","page":"Modulo Division and Rounding","title":"Base.Rounding.RoundDown","text":"RoundDown\n\nround using this rounding mode is an alias for floor.\n\n\n\n\n\n","category":"constant"},{"location":"Base/Errors/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"Base/Errors/","page":"Errors","title":"Errors","text":"# filter(t->isdefined(Core, Symbol(t)), subtypes(Exception))\nCore.ArgumentError\nCore.AssertionError\nCore.BoundsError\n# Core.ConcurrencyViolationError\nCore.DivideError\nCore.DomainError\nCore.ErrorException\nCore.InexactError\nCore.InterruptException\nCore.MethodError\nCore.OutOfMemoryError\nCore.OverflowError\nCore.ReadOnlyMemoryError\n# Core.SegmentationFault\nCore.StackOverflowError\nCore.TypeError\nCore.UndefKeywordError\nCore.UndefRefError\nCore.UndefVarError\n\n# filter(t->!isdefined(Core, Symbol(t))&&isdefined(Base, Symbol(t)), subtypes(Exception))\n# Base.CanonicalIndexError\n# Base.CapturedException\nBase.CompositeException\nBase.DimensionMismatch\nBase.EOFError\n# Base.InvalidStateException\nBase.KeyError\nBase.MissingException\nBase.ProcessFailedException\nBase.StringIndexError\nBase.SystemError\nBase.TaskFailedException","category":"page"},{"location":"Base/Errors/#Core.ArgumentError","page":"Errors","title":"Core.ArgumentError","text":"ArgumentError(msg)\n\nThe arguments passed to a function are invalid. msg is a descriptive error message.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.AssertionError","page":"Errors","title":"Core.AssertionError","text":"AssertionError([msg])\n\nThe asserted condition did not evaluate to true. Optional argument msg is a descriptive error string.\n\nExamples\n\njulia> @assert false \"this is not true\"\nERROR: AssertionError: this is not true\n\nAssertionError is usually thrown from @assert.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.BoundsError","page":"Errors","title":"Core.BoundsError","text":"BoundsError([a],[i])\n\nAn indexing operation into an array, a, tried to access an out-of-bounds element at index i.\n\nExamples\n\njulia> A = fill(1.0, 7);\n\njulia> A[8]\nERROR: BoundsError: attempt to access 7-element Vector{Float64} at index [8]\n\n\njulia> B = fill(1.0, (2,3));\n\njulia> B[2, 4]\nERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [2, 4]\n\n\njulia> B[9]\nERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [9]\n\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.DivideError","page":"Errors","title":"Core.DivideError","text":"DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\nExamples\n\njulia> 2/0\nInf\n\njulia> div(2, 0)\nERROR: DivideError: integer division error\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.DomainError","page":"Errors","title":"Core.DomainError","text":"DomainError(val)\nDomainError(val, msg)\n\nThe argument val to a function or constructor is outside the valid domain.\n\nExamples\n\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.ErrorException","page":"Errors","title":"Core.ErrorException","text":"ErrorException(msg)\n\nGeneric error type. The error message, in the .msg field, may provide more specific details.\n\nExamples\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> ex.msg\n\"I've done a bad thing\"\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.InexactError","page":"Errors","title":"Core.InexactError","text":"InexactError(name::Symbol, T, val)\n\nCannot exactly convert val to type T in a method of function name.\n\nExamples\n\njulia> convert(Float64, 1+2im)\nERROR: InexactError: Float64(1 + 2im)\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.InterruptException","page":"Errors","title":"Core.InterruptException","text":"InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\nNote that, in Julia script started without -i (interactive) option, InterruptException is not thrown by default.  Calling Base.exit_on_sigint(false) in the script can recover the behavior of the REPL.  Alternatively, a Julia script can be started with\n\njulia -e \"include(popfirst!(ARGS))\" script.jl\n\nto let InterruptException be thrown by CTRL+C during the execution.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.MethodError","page":"Errors","title":"Core.MethodError","text":"MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.OutOfMemoryError","page":"Errors","title":"Core.OutOfMemoryError","text":"OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to handle properly.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.OverflowError","page":"Errors","title":"Core.OverflowError","text":"OverflowError(msg)\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.ReadOnlyMemoryError","page":"Errors","title":"Core.ReadOnlyMemoryError","text":"ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.StackOverflowError","page":"Errors","title":"Core.StackOverflowError","text":"StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.TypeError","page":"Errors","title":"Core.TypeError","text":"TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.UndefKeywordError","page":"Errors","title":"Core.UndefKeywordError","text":"UndefKeywordError(var::Symbol)\n\nThe required keyword argument var was not assigned in a function call.\n\nExamples\n\njulia> function my_func(;my_arg)\n           return my_arg + 1\n       end\nmy_func (generic function with 1 method)\n\njulia> my_func()\nERROR: UndefKeywordError: keyword argument `my_arg` not assigned\nStacktrace:\n [1] my_func() at ./REPL[1]:2\n [2] top-level scope at REPL[2]:1\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.UndefRefError","page":"Errors","title":"Core.UndefRefError","text":"UndefRefError()\n\nThe item or field is not defined for the given object.\n\nExamples\n\njulia> struct MyType\n           a::Vector{Int}\n           MyType() = new()\n       end\n\njulia> A = MyType()\nMyType(#undef)\n\njulia> A.a\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n[...]\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Core.UndefVarError","page":"Errors","title":"Core.UndefVarError","text":"UndefVarError(var::Symbol, [scope])\n\nA symbol in the current scope is not defined.\n\nExamples\n\njulia> a\nERROR: UndefVarError: `a` not defined in `Main`\n\njulia> a = 1;\n\njulia> a\n1\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.CompositeException","page":"Errors","title":"Base.CompositeException","text":"CompositeException\n\nWrap a Vector of exceptions thrown by a Task (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under pmap) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting CompositeException will contain a \"bundle\" of information from each worker indicating where and why the exception(s) occurred.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.DimensionMismatch","page":"Errors","title":"Base.DimensionMismatch","text":"DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument msg is a descriptive error string.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.EOFError","page":"Errors","title":"Base.EOFError","text":"EOFError()\n\nNo more data was available to read from a file or stream.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.KeyError","page":"Errors","title":"Base.KeyError","text":"KeyError(key)\n\nAn indexing operation into an AbstractDict (Dict) or Set like object tried to access or delete a non-existent element.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.MissingException","page":"Errors","title":"Base.MissingException","text":"MissingException(msg)\n\nException thrown when a missing value is encountered in a situation where it is not supported. The error message, in the msg field may provide more specific details.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.ProcessFailedException","page":"Errors","title":"Base.ProcessFailedException","text":"ProcessFailedException\n\nIndicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.StringIndexError","page":"Errors","title":"Base.StringIndexError","text":"StringIndexError(str, i)\n\nAn error occurred when trying to access str at index i that is not valid.\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.SystemError","page":"Errors","title":"Base.SystemError","text":"SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the errno global variable).\n\n\n\n\n\n","category":"type"},{"location":"Base/Errors/#Base.TaskFailedException","page":"Errors","title":"Base.TaskFailedException","text":"TaskFailedException\n\nThis exception is thrown by a wait(t) call when task t fails. TaskFailedException wraps the failed task t.\n\n\n\n\n\n","category":"type"},{"location":"ElementaryMath/Polynomials/Polynomials/#Polynomials","page":"Polynomials","title":"Polynomials","text":"","category":"section"},{"location":"ElementaryMath/Polynomials/Polynomials/","page":"Polynomials","title":"Polynomials","text":"evalpoly\n@evalpoly","category":"page"},{"location":"ElementaryMath/Polynomials/Polynomials/#index","page":"Polynomials","title":"index","text":"","category":"section"},{"location":"ElementaryMath/Polynomials/Polynomials/","page":"Polynomials","title":"Polynomials","text":"Base.Math.evalpoly\nBase.Math.@evalpoly","category":"page"},{"location":"ElementaryMath/Polynomials/Polynomials/#Base.Math.evalpoly","page":"Polynomials","title":"Base.Math.evalpoly","text":"evalpoly(x, p)\n\nEvaluate the polynomial sum_k x^k-1 pk for the coefficients p[1], p[2], ...; that is, the coefficients are given in ascending order by power of x. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when p is a Tuple. This function generates efficient code using Horner's method if x is real, or using a Goertzel-like [DK62] algorithm if x is complex.\n\n[DK62]: Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.\n\ncompat: Julia 1.4\nThis function requires Julia 1.4 or later.\n\nExamples\n\njulia> evalpoly(2, (1, 2, 3))\n17\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Polynomials/Polynomials/#Base.Math.@evalpoly","page":"Polynomials","title":"Base.Math.@evalpoly","text":"@evalpoly(z, c...)\n\nEvaluate the polynomial sum_k z^k-1 ck for the coefficients c[1], c[2], ...; that is, the coefficients are given in ascending order by power of z.  This macro expands to efficient inline code that uses either Horner's method or, for complex z, a more efficient Goertzel-like algorithm.\n\nSee also evalpoly.\n\nExamples\n\njulia> @evalpoly(3, 1, 0, 1)\n10\n\njulia> @evalpoly(2, 1, 0, 1)\n5\n\njulia> @evalpoly(2, 1, 1, 1)\n7\n\n\n\n\n\n","category":"macro"},{"location":"ElementaryMath/Trigonometry/Secant/#Secant","page":"Secant","title":"Secant","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Secant/","page":"Secant","title":"Secant","text":"Base.sec\nBase.secd\nBase.sech\nBase.asec\nBase.asecd\nBase.asech","category":"page"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.sec","page":"Secant","title":"Base.Math.sec","text":"sec(x)\n\nCompute the secant of x, where x is in radians.\n\n\n\n\n\nsec(A::AbstractMatrix)\n\nCompute the matrix secant of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.secd","page":"Secant","title":"Base.Math.secd","text":"secd(x)\n\nCompute the secant of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.sech","page":"Secant","title":"Base.Math.sech","text":"sech(x)\n\nCompute the hyperbolic secant of x.\n\n\n\n\n\nsech(A::AbstractMatrix)\n\nCompute the matrix hyperbolic secant of square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.asec","page":"Secant","title":"Base.Math.asec","text":"asec(x)\n\nCompute the inverse secant of x, where the output is in radians. \n\n\n\n\n\nasec(A::AbstractMatrix)\n\nCompute the inverse matrix secant of A. \n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.asecd","page":"Secant","title":"Base.Math.asecd","text":"asecd(x)\n\nCompute the inverse secant of x, where the output is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Secant/#Base.Math.asech","page":"Secant","title":"Base.Math.asech","text":"asech(x)\n\nCompute the inverse hyperbolic secant of x. \n\n\n\n\n\nasech(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic secant of A. \n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Constants/Constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"missing\nismissing\nnothing\nisnothing\nundef\nUndefInitializer","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Math-Constants","page":"Constants","title":"Math Constants","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"pi\nπ\nℯ","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Float-Point","page":"Constants","title":"Float Point","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"eps","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Infinity","page":"Constants","title":"Infinity","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"Inf16\nInf32\nInf64\nisinf\nisfinite","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Not-a-Number","page":"Constants","title":"Not a Number","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"NaN\nNaN16\nNaN32\nNaN64\nisnan","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Complex-Number","page":"Constants","title":"Complex Number","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"im","category":"page"},{"location":"ElementaryMath/Constants/Constants/#temp-docs","page":"Constants","title":"temp docs","text":"","category":"section"},{"location":"ElementaryMath/Constants/Constants/","page":"Constants","title":"Constants","text":"Base.missing\nBase.nothing\nBase.undef\nBase.UndefInitializer\n\nBase.pi\nBase.π\nBase.ℯ\n\nBase.eps\nBase.Inf\nBase.Inf16\nBase.Inf32\nBase.Inf64\nBase.isinf\nBase.isfinite\n\nBase.NaN\nBase.NaN16\nBase.NaN32\nBase.NaN64\nBase.isnan","category":"page"},{"location":"ElementaryMath/Constants/Constants/#Base.missing","page":"Constants","title":"Base.missing","text":"missing\n\nThe singleton instance of type Missing representing a missing value.\n\nSee also: NaN, skipmissing, nonmissingtype.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Core.nothing","page":"Constants","title":"Core.nothing","text":"nothing\n\nThe singleton instance of type Nothing, used by convention when there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSee also: isnothing, something, missing.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Core.undef","page":"Constants","title":"Core.undef","text":"undef\n\nAlias for UndefInitializer(), which constructs an instance of the singleton type UndefInitializer, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.\n\nSee also: missing, similar.\n\nExamples\n\njulia> Array{Float64, 1}(undef, 3)\n3-element Vector{Float64}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Core.UndefInitializer","page":"Constants","title":"Core.UndefInitializer","text":"UndefInitializer\n\nSingleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also undef, an alias for UndefInitializer().\n\nExamples\n\njulia> Array{Float64, 1}(UndefInitializer(), 3)\n3-element Array{Float64, 1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n\n\n\n\n\n","category":"type"},{"location":"ElementaryMath/Constants/Constants/#Base.MathConstants.pi","page":"Constants","title":"Base.MathConstants.pi","text":"π\npi\n\nThe constant pi.\n\nUnicode π can be typed by writing \\pi then pressing tab in the Julia REPL, and in many editors.\n\nSee also: sinpi, sincospi, deg2rad.\n\nExamples\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> 1/2pi\n0.15915494309189535\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.MathConstants.π","page":"Constants","title":"Base.MathConstants.π","text":"π\npi\n\nThe constant pi.\n\nUnicode π can be typed by writing \\pi then pressing tab in the Julia REPL, and in many editors.\n\nSee also: sinpi, sincospi, deg2rad.\n\nExamples\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> 1/2pi\n0.15915494309189535\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.MathConstants.ℯ","page":"Constants","title":"Base.MathConstants.ℯ","text":"ℯ\ne\n\nThe constant ℯ.\n\nUnicode ℯ can be typed by writing \\euler and pressing tab in the Julia REPL, and in many editors.\n\nSee also: exp, cis, cispi.\n\nExamples\n\njulia> ℯ\nℯ = 2.7182818284590...\n\njulia> log(ℯ)\n1\n\njulia> ℯ^(im)π ≈ -1\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.eps","page":"Constants","title":"Base.eps","text":"eps(::Type{T}) where T<:AbstractFloat\neps()\n\nReturn the machine epsilon of the floating point type T (T = Float64 by default). This is defined as the gap between 1 and the next largest value representable by typeof(one(T)), and is equivalent to eps(one(T)).  (Since eps(T) is a bound on the relative error of T, it is a \"dimensionless\" quantity like one.)\n\nExamples\n\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n\n\n\n\n\neps(x::AbstractFloat)\n\nReturn the unit in last place (ulp) of x. This is the distance between consecutive representable floating point values at x. In most cases, if the distance on either side of x is different, then the larger of the two is taken, that is\n\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values (e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the smaller of the values.\n\nThe rationale for this behavior is that eps bounds the floating point rounding error. Under the default RoundNearest rounding mode, if y is a real number and x is the nearest floating point number to y, then\n\ny-x leq operatornameeps(x)2\n\nSee also: nextfloat, issubnormal, floatmax.\n\nExamples\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Constants/Constants/#Base.Inf","page":"Constants","title":"Base.Inf","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\nSee also: isfinite, typemax, NaN, Inf32.\n\nExamples\n\njulia> π/0\nInf\n\njulia> +1.0 / -0.0\n-Inf\n\njulia> ℯ^-Inf\n0.0\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.Inf16","page":"Constants","title":"Base.Inf16","text":"Inf16\n\nPositive infinity of type Float16.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.Inf32","page":"Constants","title":"Base.Inf32","text":"Inf32\n\nPositive infinity of type Float32.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.Inf64","page":"Constants","title":"Base.Inf64","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\nSee also: isfinite, typemax, NaN, Inf32.\n\nExamples\n\njulia> π/0\nInf\n\njulia> +1.0 / -0.0\n-Inf\n\njulia> ℯ^-Inf\n0.0\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.isinf","page":"Constants","title":"Base.isinf","text":"isinf(f) -> Bool\n\nTest whether a number is infinite.\n\nSee also: Inf, iszero, isfinite, isnan.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Constants/Constants/#Base.isfinite","page":"Constants","title":"Base.isfinite","text":"isfinite(f) -> Bool\n\nTest whether a number is finite.\n\nExamples\n\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Constants/Constants/#Base.NaN","page":"Constants","title":"Base.NaN","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\nSee also: isnan, missing, NaN32, Inf.\n\nExamples\n\njulia> 0/0\nNaN\n\njulia> Inf - Inf\nNaN\n\njulia> NaN == NaN, isequal(NaN, NaN), isnan(NaN)\n(false, true, true)\n\nnote: Note\nAlways use isnan or isequal for checking for NaN. Using x === NaN may give unexpected results:julia> reinterpret(UInt32, NaN32)\n0x7fc00000\n\njulia> NaN32p1 = reinterpret(Float32, 0x7fc00001)\nNaN32\n\njulia> NaN32p1 === NaN32, isequal(NaN32p1, NaN32), isnan(NaN32p1)\n(false, true, true)\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.NaN16","page":"Constants","title":"Base.NaN16","text":"NaN16\n\nA not-a-number value of type Float16.\n\nSee also: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.NaN32","page":"Constants","title":"Base.NaN32","text":"NaN32\n\nA not-a-number value of type Float32.\n\nSee also: NaN.\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.NaN64","page":"Constants","title":"Base.NaN64","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\nSee also: isnan, missing, NaN32, Inf.\n\nExamples\n\njulia> 0/0\nNaN\n\njulia> Inf - Inf\nNaN\n\njulia> NaN == NaN, isequal(NaN, NaN), isnan(NaN)\n(false, true, true)\n\nnote: Note\nAlways use isnan or isequal for checking for NaN. Using x === NaN may give unexpected results:julia> reinterpret(UInt32, NaN32)\n0x7fc00000\n\njulia> NaN32p1 = reinterpret(Float32, 0x7fc00001)\nNaN32\n\njulia> NaN32p1 === NaN32, isequal(NaN32p1, NaN32), isnan(NaN32p1)\n(false, true, true)\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Constants/Constants/#Base.isnan","page":"Constants","title":"Base.isnan","text":"isnan(f) -> Bool\n\nTest whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number (\"not a number\").\n\nSee also: iszero, isone, isinf, ismissing.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/sinh/#sinh","page":"sinh","title":"sinh","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sinh/","page":"sinh","title":"sinh","text":"Base.sinh","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sinh/#Base.sinh","page":"sinh","title":"Base.sinh","text":"sinh(x)\n\nCompute hyperbolic sine of x.\n\n\n\n\n\nsinh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic sine of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/SpecialFunctions/#Special-Functions","page":"Special Functions","title":"Special Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/","page":"Special Functions","title":"Special Functions","text":"tip: SpecialFunctions.jl\n🔗JuliaMath/SpecialFunctions.jl – Special mathematical functions in JuliaSpecial mathematical functions in Julia, include Bessel, Hankel, Airy, error, Dawson, exponential (or sine and cosine) integrals, eta, zeta, digamma, inverse digamma, trigamma, and polygamma functions. Most of these functions were formerly part of Base in early versions of Julia.","category":"page"},{"location":"ElementaryMath/SpecialFunctions/","page":"Special Functions","title":"Special Functions","text":"See Also: Special Functions Pkg","category":"page"},{"location":"ElementaryMath/SpecialFunctions/#External-Links","page":"Special Functions","title":"External Links","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/","page":"Special Functions","title":"Special Functions","text":"🔗Special functions - Wikipedia\n🔗NIST Digital Library of Mathematical Functions - DLMF\n🔗Special Functions Wiki","category":"page"},{"location":"ElementaryMath/Arithmetic/Relational/#Relational-Operations","page":"Relational Operations","title":"Relational Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Relational/","page":"Relational Operations","title":"Relational Operations","text":"===\n==\n>=\n>\n<=\n<\n!=\n!==\nisequal\nisless\nisunordered","category":"page"},{"location":"ElementaryMath/Arithmetic/Relational/#Core.:===","page":"Relational Operations","title":"Core.:===","text":"===(x,y) -> Bool\n≡(x,y) -> Bool\n\nDetermine whether x and y are identical, in the sense that no program could distinguish them. First the types of x and y are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called \"egal\". It always returns a Bool value.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a == b\ntrue\n\njulia> a === b\nfalse\n\njulia> a === a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:==","page":"Relational Operations","title":"Base.:==","text":"==(x, y)\n\nGeneric equality operator. Falls back to ===. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. Collections of the same type generally compare their key sets, and if those are ==, then compare the values for each of those keys, returning true if all such pairs are ==. Other properties are typically not taken into account (such as the exact type).\n\nThis operator follows IEEE semantics for floating-point numbers: 0.0 == -0.0 and NaN != NaN.\n\nThe result is of type Bool, except when one of the operands is missing, in which case missing is returned (three-valued logic). Collections generally implement three-valued logic akin to all, returning missing if any operands contain missing values and all other pairs are equal. Use isequal or === to always get a Bool result.\n\nImplementation\n\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\n\nisequal falls back to ==, so new methods of == will be used by the Dict type to compare keys. If your type will be used as a dictionary key, it should therefore also implement hash.\n\nIf some type defines ==, isequal, and isless then it should also implement < to ensure consistency of comparisons.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:>=","page":"Relational Operations","title":"Base.:>=","text":">=(x, y)\n≥(x,y)\n\nGreater-than-or-equals comparison operator. Falls back to y <= x.\n\nExamples\n\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n\n\n\n\n\n>=(x)\n\nCreate a function that compares its argument to x using >=, i.e. a function equivalent to y -> y >= x. The returned function is of type Base.Fix2{typeof(>=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:>","page":"Relational Operations","title":"Base.:>","text":">(x, y)\n\nGreater-than comparison operator. Falls back to y < x.\n\nImplementation\n\nGenerally, new types should implement < instead of this function, and rely on the fallback definition >(x, y) = y < x.\n\nExamples\n\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n\n\n\n\n\n>(x)\n\nCreate a function that compares its argument to x using >, i.e. a function equivalent to y -> y > x. The returned function is of type Base.Fix2{typeof(>)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:<=","page":"Relational Operations","title":"Base.:<=","text":"<=(x, y)\n≤(x,y)\n\nLess-than-or-equals comparison operator. Falls back to (x < y) | (x == y).\n\nExamples\n\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n\n\n\n\n\n<=(x)\n\nCreate a function that compares its argument to x using <=, i.e. a function equivalent to y -> y <= x. The returned function is of type Base.Fix2{typeof(<=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:<","page":"Relational Operations","title":"Base.:<","text":"<(x, y)\n\nLess-than comparison operator. Falls back to isless. Because of the behavior of floating-point NaN values, this operator implements a partial order.\n\nImplementation\n\nNew types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement isless instead.\n\nSee also isunordered.\n\nExamples\n\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n\n\n\n\n\n<(x)\n\nCreate a function that compares its argument to x using <, i.e. a function equivalent to y -> y < x. The returned function is of type Base.Fix2{typeof(<)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:!=","page":"Relational Operations","title":"Base.:!=","text":"!=(x, y)\n≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as ==.\n\nImplementation\n\nNew types should generally not implement this, and rely on the fallback definition !=(x,y) = !(x==y) instead.\n\nExamples\n\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n\n\n\n\n\n!=(x)\n\nCreate a function that compares its argument to x using !=, i.e. a function equivalent to y -> y != x. The returned function is of type Base.Fix2{typeof(!=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.:!==","page":"Relational Operations","title":"Base.:!==","text":"!==(x, y)\n≢(x,y)\n\nAlways gives the opposite answer as ===.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.isequal","page":"Relational Operations","title":"Base.isequal","text":"isequal(x, y) -> Bool\n\nSimilar to ==, except for the treatment of floating point numbers and of missing values. isequal treats all floating-point NaN values as equal to each other, treats -0.0 as unequal to 0.0, and missing as equal to missing. Always returns a Bool value.\n\nisequal is an equivalence relation - it is reflexive (=== implies isequal), symmetric (isequal(a, b) implies isequal(b, a)) and transitive (isequal(a, b) and isequal(b, c) implies isequal(a, c)).\n\nImplementation\n\nThe default implementation of isequal calls ==, so a type that does not involve floating-point values generally only needs to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\n\nThis typically means that types for which a custom == or isequal method exists must implement a corresponding hash method (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\n\nFurthermore, isequal is linked with isless, and they work together to define a fixed total ordering, where exactly one of isequal(x, y), isless(x, y), or isless(y, x) must be true (and the other two false).\n\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\n\nExamples\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\njulia> missing == missing\nmissing\n\njulia> isequal(missing, missing)\ntrue\n\n\n\n\n\nisequal(x)\n\nCreate a function that compares its argument to x using isequal, i.e. a function equivalent to y -> isequal(y, x).\n\nThe returned function is of type Base.Fix2{typeof(isequal)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.isless","page":"Relational Operations","title":"Base.isless","text":"isless(x, y)\n\nTest whether x is less than y, according to a fixed total order (defined together with isequal). isless is not defined for pairs (x, y) of all types. However, if it is defined, it is expected to satisfy the following:\n\nIf isless(x, y) is defined, then so is isless(y, x) and isequal(x, y), and exactly one of those three yields true.\nThe relation defined by isless is transitive, i.e., isless(x, y) && isless(y, z) implies isless(x, z).\n\nValues that are normally unordered, such as NaN, are ordered after regular values. missing values are ordered last.\n\nThis is the default comparison used by sort!.\n\nImplementation\n\nNon-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as NaN. Types with a partial order should implement <. See the documentation on Alternate Orderings for how to define alternate ordering methods that can be used in sorting and related functions.\n\nExamples\n\njulia> isless(1, 3)\ntrue\n\njulia> isless(\"Red\", \"Blue\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Relational/#Base.isunordered","page":"Relational Operations","title":"Base.isunordered","text":"isunordered(x)\n\nReturn true if x is a value that is not orderable according to <, such as NaN or missing.\n\nThe values that evaluate to true with this predicate may be orderable with respect to other orderings such as isless.\n\ncompat: Julia 1.7\nThis function requires Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/cospi/#cospi","page":"cospi","title":"cospi","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cospi/","page":"cospi","title":"cospi","text":"Base.cospi","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cospi/#Base.Math.cospi","page":"cospi","title":"Base.Math.cospi","text":"cospi(x)\n\nCompute cos(pi x) more accurately than cos(pi*x), especially for large x.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/SinCos/sincos/#sincos","page":"sincos","title":"sincos","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/SinCos/sincos/","page":"sincos","title":"sincos","text":"Base.sincos","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/sincos/#Base.Math.sincos","page":"sincos","title":"Base.Math.sincos","text":"sincos(x)\n\nSimultaneously compute the sine and cosine of x, where x is in radians, returning a tuple (sine, cosine).\n\nSee also cis, sincospi, sincosd.\n\n\n\n\n\nsincos(A::AbstractMatrix)\n\nCompute the matrix sine and cosine of a square matrix A.\n\nExamples\n\njulia> S, C = sincos(fill(1.0, (2,2)));\n\njulia> S\n2×2 Matrix{Float64}:\n 0.454649  0.454649\n 0.454649  0.454649\n\njulia> C\n2×2 Matrix{Float64}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Powers/#Powers","page":"Powers","title":"Powers","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Powers/","page":"Powers","title":"Powers","text":"Base.:^(::Number, ::Number)","category":"page"},{"location":"ElementaryMath/Arithmetic/Powers/#Base.:^-Tuple{Number, Number}","page":"Powers","title":"Base.:^","text":"^(x, y)\n\nExponentiation operator.\n\nIf x and y are integers, the result may overflow. To enter numbers in scientific notation, use Float64 literals such as 1.2e3 rather than 1.2 * 10^3.\n\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code x^y is transformed by the compiler to Base.literal_pow(^, x, Val(y)), to enable compile-time specialization on the value of the exponent. (As a default fallback we have Base.literal_pow(^, x, Val(y)) = ^(x,y), where usually ^ == Base.^ unless ^ has been defined in the calling namespace.) If y is a negative integer literal, then Base.literal_pow transforms the operation to inv(x)^-y by default, where -y is positive.\n\nSee also exp2, <<.\n\nExamples\n\njulia> 3^5\n243\n\njulia> 3^-1  # uses Base.literal_pow\n0.3333333333333333\n\njulia> p = -1;\n\njulia> 3^p\nERROR: DomainError with -1:\nCannot raise an integer x to a negative power -1.\n[...]\n\njulia> 3.0^p\n0.3333333333333333\n\njulia> 10^19 > 0  # integer overflow\nfalse\n\njulia> big(10)^19 == 1e19\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Trigonometry/Sine/sinpi/#sinpi","page":"sinpi","title":"sinpi","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sinpi/","page":"sinpi","title":"sinpi","text":"Base.sinpi","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sinpi/#Base.Math.sinpi","page":"sinpi","title":"Base.Math.sinpi","text":"sinpi(x)\n\nCompute sin(pi x) more accurately than sin(pi*x), especially for large x.\n\nSee also sind, cospi, sincospi.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Logical/#Logical-Operations","page":"Logical Operations","title":"Logical Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Logical/#Boolean-Operations","page":"Logical Operations","title":"Boolean Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Logical/","page":"Logical Operations","title":"Logical Operations","text":"true\nfalse\n!\n&&\n||\nall\nany","category":"page"},{"location":"ElementaryMath/Arithmetic/Logical/#Base.:!","page":"Logical Operations","title":"Base.:!","text":"!(x)\n\nBoolean not. Implements three-valued logic, returning missing if x is missing.\n\nSee also ~ for bitwise not.\n\nExamples\n\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> !missing\nmissing\n\njulia> .![true false true]\n1×3 BitMatrix:\n 0  1  0\n\n\n\n\n\n!f::Function\n\nPredicate function negation: when the argument of ! is a function, it returns a composed function which computes the boolean negation of f.\n\nSee also ∘.\n\nExamples\n\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isletter, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isletter, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n\ncompat: Julia 1.9\nStarting with Julia 1.9, !f returns a ComposedFunction instead of an anonymous function.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Logical/#&&","page":"Logical Operations","title":"&&","text":"x && y\n\nShort-circuiting boolean AND.\n\nSee also &, the ternary operator ? :, and the manual section on control flow.\n\nExamples\n\njulia> x = 3;\n\njulia> x > 1 && x < 10 && x isa Int\ntrue\n\njulia> x < 0 && error(\"expected positive x\")\nfalse\n\n\n\n\n\n","category":"keyword"},{"location":"ElementaryMath/Arithmetic/Logical/#||","page":"Logical Operations","title":"||","text":"x || y\n\nShort-circuiting boolean OR.\n\nSee also: |, xor, &&.\n\nExamples\n\njulia> pi < 3 || ℯ < 3\ntrue\n\njulia> false || true || println(\"neither is true!\")\ntrue\n\n\n\n\n\n","category":"keyword"},{"location":"ElementaryMath/Arithmetic/Logical/#Base.all","page":"Logical Operations","title":"Base.all","text":"all(itr) -> Bool\n\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting). To short-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nSee also: all!, any, count, &, , &&, allunique.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n\n\n\n\n\nall(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting). To short-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\nall(A; dims)\n\nTest whether all values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true true]\n2×2 Matrix{Bool}:\n 1  0\n 1  1\n\njulia> all(A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\nall(p, A; dims)\n\nDetermine whether predicate p returns true for all elements along the given dimensions of an array.\n\nExamples\n\njulia> A = [1 -1; 2 2]\n2×2 Matrix{Int64}:\n 1  -1\n 2   2\n\njulia> all(i -> i > 0, A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(i -> i > 0, A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Logical/#Base.any","page":"Logical Operations","title":"Base.any","text":"any(itr) -> Bool\n\nTest whether any elements of a boolean collection are true, returning true as soon as the first true value in itr is encountered (short-circuiting). To short-circuit on false, use all.\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nSee also: all, count, sum, |, , ||.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\njulia> any([missing, true])\ntrue\n\njulia> any([false, missing])\nmissing\n\n\n\n\n\nany(p, itr) -> Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting). To short-circuit on false, use all.\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n\n\n\n\n\nany(A; dims)\n\nTest whether any values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> any(A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> any(A, dims=2)\n2×1 Matrix{Bool}:\n 1\n 1\n\n\n\n\n\nany(p, A; dims)\n\nDetermine whether predicate p returns true for any elements along the given dimensions of an array.\n\nExamples\n\njulia> A = [1 -1; 2 -2]\n2×2 Matrix{Int64}:\n 1  -1\n 2  -2\n\njulia> any(i -> i > 0, A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> any(i -> i > 0, A, dims=2)\n2×1 Matrix{Bool}:\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Exponents/#Exponents","page":"Exponents","title":"Exponents","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/Exponents/","page":"Exponents","title":"Exponents","text":"Base.exp\nBase.expm1\nBase.exp2\nBase.exp10","category":"page"},{"location":"ElementaryMath/Exp-and-Log/Exponents/#Base.exp","page":"Exponents","title":"Base.exp","text":"exp(x)\n\nCompute the natural base exponential of x, in other words ℯ^x.\n\nSee also exp2, exp10 and cis.\n\nExamples\n\njulia> exp(1.0)\n2.718281828459045\n\njulia> exp(im * pi) ≈ cis(pi)\ntrue\n\n\n\n\n\nexp(A::AbstractMatrix)\n\nCompute the matrix exponential of A, defined by\n\ne^A = sum_n=0^infty fracA^nn\n\nFor symmetric or Hermitian A, an eigendecomposition (eigen) is used, otherwise the scaling and squaring algorithm (see [H05]) is chosen.\n\n[H05]: Nicholas J. Higham, \"The squaring and scaling method for the matrix exponential revisited\", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. doi:10.1137/090768539\n\nExamples\n\njulia> A = Matrix(1.0I, 2, 2)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> exp(A)\n2×2 Matrix{Float64}:\n 2.71828  0.0\n 0.0      2.71828\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Exponents/#Base.expm1","page":"Exponents","title":"Base.expm1","text":"expm1(x)\n\nAccurately compute e^x-1. It avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small values of x.\n\nExamples\n\njulia> expm1(1e-16)\n1.0e-16\n\njulia> exp(1e-16) - 1\n0.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Exponents/#Base.exp2","page":"Exponents","title":"Base.exp2","text":"exp2(x)\n\nCompute the base 2 exponential of x, in other words 2^x.\n\nSee also ldexp, <<.\n\nExamples\n\njulia> exp2(5)\n32.0\n\njulia> 2^5\n32\n\njulia> exp2(63) > typemax(Int)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Exponents/#Base.exp10","page":"Exponents","title":"Base.exp10","text":"exp10(x)\n\nCompute the base 10 exponential of x, in other words 10^x.\n\nExamples\n\njulia> exp10(2)\n100.0\n\njulia> 10^2\n100\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/SinCos/cispi/#cispi","page":"cispi","title":"cispi","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/SinCos/cispi/","page":"cispi","title":"cispi","text":"Base.cispi","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/cispi/#Base.cispi","page":"cispi","title":"Base.cispi","text":"cispi(x)\n\nMore accurate method for cis(pi*x) (especially for large x).\n\nSee also cis, sincospi, exp, angle.\n\nExamples\n\njulia> cispi(10000)\n1.0 + 0.0im\n\njulia> cispi(0.25 + 1im)\n0.030556854645954562 + 0.03055685464595456im\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Arithmetic-Operations","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Basic-Arithmetic","page":"Arithmetic Operations","title":"Basic Arithmetic","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"accumulate\naccumulate!","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Addition","page":"Arithmetic Operations","title":"Addition","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"+\nsum\nsum!\ncumsum\ncumsum!\nadd_sum","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Subtraction","page":"Arithmetic Operations","title":"Subtraction","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"-\ndiff","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Multiplication","page":"Arithmetic Operations","title":"Multiplication","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"*\nprod\ncumprod","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Division","page":"Arithmetic Operations","title":"Division","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"/\n\\\n//","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Powers","page":"Arithmetic Operations","title":"Powers","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"^","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Transpose","page":"Arithmetic Operations","title":"Transpose","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"adjoint\ntranspose","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Modulo-Division-and-Rounding","page":"Arithmetic Operations","title":"Modulo Division and Rounding","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"mod\nmod1\ninvmod\nrem\ndiv\n÷\ndivrem\nfld\nfld1\nfldmod\nfldmod1\ncld\nceil\nfloor\nround","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Relational-Operations","page":"Arithmetic Operations","title":"Relational Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"===\n==\n>=\n>\n<=\n<\n!=\n!==\nisequal\nisless\nisunordered","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Logical-Operations","page":"Arithmetic Operations","title":"Logical Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Boolean-Operations","page":"Arithmetic Operations","title":"Boolean Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"true\nfalse\n!\n&&\n||\nall\nany","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Bit-Wise-Operations","page":"Arithmetic Operations","title":"Bit-Wise Operations","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"~\n&\n|\nxor\n⊻","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Shift","page":"Arithmetic Operations","title":"Shift","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"<<\n>>\n>>>","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#temp-docs","page":"Arithmetic Operations","title":"temp-docs","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Arithmetic/","page":"Arithmetic Operations","title":"Arithmetic Operations","text":"Base.accumulate\nBase.accumulate!","category":"page"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Base.accumulate","page":"Arithmetic Operations","title":"Base.accumulate","text":"accumulate(op, A; dims::Integer, [init])\n\nCumulative operation op along the dimension dims of A (providing dims is optional for vectors). An initial value init may optionally be provided by a keyword argument. See also accumulate! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nFor common operations there are specialized variants of accumulate, see cumsum, cumprod. For a lazy version, see Iterators.accumulate.\n\ncompat: Julia 1.5\naccumulate on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> accumulate(+, [1,2,3])\n3-element Vector{Int64}:\n 1\n 3\n 6\n\njulia> accumulate(min, (1, -2, 3, -4, 5), init=0)\n(0, -2, -2, -4, -4)\n\njulia> accumulate(/, (2, 4, Inf), init=100)\n(50.0, 12.5, 0.0)\n\njulia> accumulate(=>, i^2 for i in 1:3)\n3-element Vector{Any}:\n          1\n        1 => 4\n (1 => 4) => 9\n\njulia> accumulate(+, fill(1, 3, 4))\n3×4 Matrix{Int64}:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\njulia> accumulate(+, fill(1, 2, 5), dims=2, init=100.0)\n2×5 Matrix{Float64}:\n 101.0  102.0  103.0  104.0  105.0\n 101.0  102.0  103.0  104.0  105.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Arithmetic/#Base.accumulate!","page":"Arithmetic Operations","title":"Base.accumulate!","text":"accumulate!(op, B, A; [dims], [init])\n\nCumulative operation op on A along the dimension dims, storing the result in B. Providing dims is optional for vectors.  If the keyword argument init is given, its value is used to instantiate the accumulation.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nSee also accumulate, cumsum!, cumprod!.\n\nExamples\n\njulia> x = [1, 0, 2, 0, 3];\n\njulia> y = rand(5);\n\njulia> accumulate!(+, y, x);\n\njulia> y\n5-element Vector{Float64}:\n 1.0\n 1.0\n 3.0\n 3.0\n 6.0\n\njulia> A = [1 2 3; 4 5 6];\n\njulia> B = similar(A);\n\njulia> accumulate!(-, B, A, dims=1)\n2×3 Matrix{Int64}:\n  1   2   3\n -3  -3  -3\n\njulia> accumulate!(*, B, A, dims=2, init=10)\n2×3 Matrix{Int64}:\n 10   20    60\n 40  200  1200\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Trigonometry","page":"Trigonometry","title":"Trigonometry","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"NOTE: Need to have a function auto-generated:   function name + one sentence description","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Sine","page":"Trigonometry","title":"Sine","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"sin\nsind\nsinpi\nasin\nasind\nsinh\nasinh","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"sin like","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"sinc","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Sin-and-Cos","page":"Trigonometry","title":"Sin and Cos","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"sincos\nsincosd\nsincospi\ncis\ncispi","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Cosine","page":"Trigonometry","title":"Cosine","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"cos\ncosd\ncospi\nacos\nacosd\ncosh\nacosh","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"cos like","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"cosc","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Tangent","page":"Trigonometry","title":"Tangent","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"tan\ntand\ntanpi\natan\natand\natan2(y, x) => atand(y, x)\ntanh\natanh","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Cosecant","page":"Trigonometry","title":"Cosecant","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"csc\ncscd\nacsc\nacscd\ncsch\nacsch","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Secant","page":"Trigonometry","title":"Secant","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"sec\nsecd\nasec\nasecd\nsech\nasech","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Cotangent","page":"Trigonometry","title":"Cotangent","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"cot\ncotd\nacot\nacotd\ncoth\nacoth","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Hypotenuse","page":"Trigonometry","title":"Hypotenuse","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"hypot","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/#Conversions","page":"Trigonometry","title":"Conversions","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"Degrees/Radians Conversion","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"rad2deg\ndeg2rad","category":"page"},{"location":"ElementaryMath/Trigonometry/Trigonometry/","page":"Trigonometry","title":"Trigonometry","text":"Coordinate Conversioncart2pol\ncart2sph\npol2cart\nsph2cart","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/asinh/#asinh","page":"asinh","title":"asinh","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/asinh/","page":"asinh","title":"asinh","text":"Base.asinh","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/asinh/#Base.asinh","page":"asinh","title":"Base.asinh","text":"asinh(x)\n\nCompute the inverse hyperbolic sine of x.\n\n\n\n\n\nasinh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix sine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_5].\n\n[AH16_5]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"function"},{"location":"dev/#Dev-Memo","page":"Dev Memo","title":"Dev Memo","text":"","category":"section"},{"location":"dev/#Reference-docs","page":"Dev Memo","title":"Reference docs","text":"","category":"section"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"exception","category":"page"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"🔗Ruby's Exceptional Creatures","category":"page"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"sin","category":"page"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"🔗Matlab - sin\n🔗Wolfram - Sin\n🔗Python numpy - sin\n🔗DLMF - Trigonometric Functions\n🔗WikiPedia - Sine and Cosine\n🔗R - Trig","category":"page"},{"location":"dev/#matlab","page":"Dev Memo","title":"matlab","text":"","category":"section"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"One sentence description\nSyntax\nDescription\nExamples, with plot\nInput Arguments\nOutput Arguments\nMore About\nTips\nExtended Capabilities\nVersion History\nSee Also (links)","category":"page"},{"location":"dev/#wolfram","page":"Dev Memo","title":"wolfram","text":"","category":"section"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"Details, Some definitions and facts\nBackground & Context\nExamples\nBasic Examples: most common use cases\nScope: Survey of the scope of standard use cases\nApplications: Sample problems that can be solved with this function\nProperties & Relations: Properties of the function, and connections to other functions\nPossible Issues: Common pitfalls and unexpected behavior\nNeat Examples: Surprising or curious use cases\nSee Also (links)\nTech Notes (links)\nRelated Guides (links)\nRelated Links\nHistory","category":"page"},{"location":"dev/#numpy","page":"Dev Memo","title":"numpy","text":"","category":"section"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"func def\nParameters\nSee Also (links)\nNotes\nExamples, with plot","category":"page"},{"location":"dev/#R","page":"Dev Memo","title":"R","text":"","category":"section"},{"location":"dev/","page":"Dev Memo","title":"Dev Memo","text":"Description\nUsage\nArguments\nValue, special value\nComplex values, branch cuts\nDetails, impl details\nReferences\nExamples","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/sincospi/#sincospi","page":"sincospi","title":"sincospi","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/SinCos/sincospi/","page":"sincospi","title":"sincospi","text":"Base.sincospi","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/sincospi/#Base.Math.sincospi","page":"sincospi","title":"Base.Math.sincospi","text":"sincospi(x)\n\nSimultaneously compute sinpi(x) and cospi(x) (the sine and cosine of π*x, where x is in radians), returning a tuple (sine, cosine).\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\nSee also: cispi, sincosd, sinpi.\n\n\n\n\n\n","category":"function"},{"location":"dev/How-to/#How-to-Guides","page":"How-to Guides","title":"How-to Guides","text":"","category":"section"},{"location":"dev/How-to/","page":"How-to Guides","title":"How-to Guides","text":"tip: Doc from\nThis is How-to guides. Also known as: Discussion, Background, Conceptual guides, Topics.Temporary hosting only, maybe transfer to a separate project.","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sind/#sind","page":"sind","title":"sind","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sind/","page":"sind","title":"sind","text":"Base.sind","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sind/#Base.Math.sind","page":"sind","title":"Base.Math.sind","text":"sind(x)\n\nCompute sine of x, where x is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Subtraction/Subtraction/#Subtraction","page":"Subtraction","title":"Subtraction","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Subtraction/Subtraction/","page":"Subtraction","title":"Subtraction","text":"Base.:-(::Any)\nBase.:-(::Any, ::Any)\nBase.diff","category":"page"},{"location":"ElementaryMath/Arithmetic/Subtraction/Subtraction/#Base.:--Tuple{Any}","page":"Subtraction","title":"Base.:-","text":"-(x)\n\nUnary minus operator.\n\nSee also: abs, flipsign.\n\nExamples\n\njulia> -1\n-1\n\njulia> -(2)\n-2\n\njulia> -[1 2; 3 4]\n2×2 Matrix{Int64}:\n -1  -2\n -3  -4\n\njulia> -(true)  # promotes to Int\n-1\n\njulia> -(0x003)\n0xfffd\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Arithmetic/Subtraction/Subtraction/#Base.:--Tuple{Any, Any}","page":"Subtraction","title":"Base.:-","text":"-(x, y)\n\nSubtraction operator.\n\nExamples\n\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Arithmetic/Subtraction/Subtraction/#Base.diff","page":"Subtraction","title":"Base.diff","text":"diff(A::AbstractVector)\ndiff(A::AbstractArray; dims::Integer)\n\nFinite difference operator on a vector or a multidimensional array A. In the latter case the dimension to operate on needs to be specified with the dims keyword argument.\n\ncompat: Julia 1.1\ndiff for arrays with dimension higher than 2 requires at least Julia 1.1.\n\nExamples\n\njulia> a = [2 4; 6 16]\n2×2 Matrix{Int64}:\n 2   4\n 6  16\n\njulia> diff(a, dims=2)\n2×1 Matrix{Int64}:\n  2\n 10\n\njulia> diff(vec(a))\n3-element Vector{Int64}:\n  4\n -2\n 12\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/cosd/#cosd","page":"cosd","title":"cosd","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cosd/","page":"cosd","title":"cosd","text":"Base.cosd","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cosd/#Base.Math.cosd","page":"cosd","title":"Base.Math.cosd","text":"cosd(x)\n\nCompute cosine of x, where x is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#acos","page":"acos","title":"acos","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"Compute the arc cosine of x, where the output is in radians.","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"For x in range [-1, 1], return value in range [0, pi]\nOtherwise, throw a DomainError","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"using LinearAlgebra","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"Base.acos(::Real)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Base.acos-Tuple{Real}","page":"acos","title":"Base.acos","text":"acos(x)\n\nCompute the inverse cosine of x, where the output is in radians\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Methods","page":"acos","title":"Methods","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"methods(acos, (Any,), [Base, Base.Math, Base.MathConstants, Base.MPFR])","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Examples","page":"acos","title":"Examples","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"using UnicodePlots\nlineplot(-1, 1, acos; ylim=(0, pi))","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Real-Numbers","page":"acos","title":"Real Numbers","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"julia> acos(1.0)\n0.0\n\njulia> acos(0.0)\n1.5707963267948966\n\njulia> acos(-1.0)\n3.141592653589793\n\njulia> acos(2.0)\nERROR: DomainError with 2.0:\nacos(x) not defined for |x| > 1\nStacktrace:\n[...]","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Complex","page":"acos","title":"Complex","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"julia> acos(2.0+0im)\n0.0 - 1.3169578969248166im\n\njulia> acos(2.0-0im)\n0.0 + 1.3169578969248166im\n\njulia> acos(-2.0+0im)\n3.141592653589793 - 1.3169578969248166im\n\njulia> acos(-2.0-0im)\n3.141592653589793 + 1.3169578969248166im","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Tips","page":"acos","title":"Tips","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"For real number input, the input range is limited to [0, 1].   For larger ranges, use complex inputs.\nThe output is expressed in radians,   and needs to be converted if a degrees is required:   degrees = radians * 180 / pi","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#See-Also","page":"acos","title":"See Also","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"cos, acosd, acosh","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Extended-Inputs","page":"acos","title":"Extended Inputs","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Matrix","page":"acos","title":"Matrix","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"With Array like input:","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"LinearAlgebra.acos(::AbstractMatrix)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Base.acos-Tuple{AbstractMatrix}","page":"acos","title":"Base.acos","text":"acos(A::AbstractMatrix)\n\nCompute the inverse matrix cosine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_1].\n\n[AH16_1]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> acos(cos([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5-8.32667e-17im  0.1+0.0im\n -0.2+2.63678e-16im  0.3-3.46945e-16im\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"methods(acos, (Any,), [LinearAlgebra])","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"julia> acos([-1 0; 0 -1])\n2×2 Matrix{Float64}:\n 3.14159  0.0\n 0.0      3.14159","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Tech-Notes","page":"acos","title":"Tech Notes","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"acos(::Real): by pure julia\nacos(::BigFloat): by MPFR","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#Version-History","page":"acos","title":"Version History","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"Introduced in 2018 (1.0)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/#External-Links","page":"acos","title":"External Links","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acos/","page":"acos","title":"acos","text":"🔗Inverse trigonometric functions - Wikipedia\n🔗Inverse Cosine - Wolfram MathWorld","category":"page"},{"location":"ElementaryMath/Arithmetic/Checked/#Checked-Math","page":"Checked Math","title":"Checked Math","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Checked/","page":"Checked Math","title":"Checked Math","text":"Base.Checked\nBase.Checked.checked_abs\nBase.Checked.checked_neg\nBase.Checked.checked_add\nBase.Checked.checked_sub\nBase.Checked.checked_mul\nBase.Checked.checked_div\nBase.Checked.checked_rem\nBase.Checked.checked_fld\nBase.Checked.checked_mod\nBase.Checked.checked_cld","category":"page"},{"location":"ElementaryMath/Arithmetic/Checked/#With-Overflow","page":"Checked Math","title":"With Overflow","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Checked/","page":"Checked Math","title":"Checked Math","text":"Base.Checked.add_with_overflow\nBase.Checked.sub_with_overflow\nBase.Checked.mul_with_overflow","category":"page"},{"location":"ElementaryMath/Arithmetic/Checked/#index","page":"Checked Math","title":"index","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Checked/","page":"Checked Math","title":"Checked Math","text":"Base.Checked\nBase.Checked.checked_abs\nBase.Checked.checked_neg\nBase.Checked.checked_add\nBase.Checked.checked_sub\nBase.Checked.checked_mul\nBase.Checked.checked_div\nBase.Checked.checked_rem\nBase.Checked.checked_fld\nBase.Checked.checked_mod\nBase.Checked.checked_cld\nBase.Checked.add_with_overflow\nBase.Checked.sub_with_overflow\nBase.Checked.mul_with_overflow","category":"page"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked","page":"Checked Math","title":"Base.Checked","text":"Checked\n\nThe Checked module provides arithmetic functions for the built-in signed and unsigned Integer types which throw an error when an overflow occurs. They are named like checked_sub, checked_div, etc. In addition, add_with_overflow, sub_with_overflow, mul_with_overflow return both the unchecked results and a boolean value denoting the presence of an overflow.\n\n\n\n\n\n","category":"module"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_abs","page":"Checked Math","title":"Base.Checked.checked_abs","text":"Base.checked_abs(x)\n\nCalculates abs(x), checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent abs(typemin(Int)), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_neg","page":"Checked Math","title":"Base.Checked.checked_neg","text":"Base.checked_neg(x)\n\nCalculates -x, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent -typemin(Int), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_add","page":"Checked Math","title":"Base.Checked.checked_add","text":"Base.checked_add(x, y)\n\nCalculates x+y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_sub","page":"Checked Math","title":"Base.Checked.checked_sub","text":"Base.checked_sub(x, y)\n\nCalculates x-y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_mul","page":"Checked Math","title":"Base.Checked.checked_mul","text":"Base.checked_mul(x, y)\n\nCalculates x*y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_div","page":"Checked Math","title":"Base.Checked.checked_div","text":"Base.checked_div(x, y)\n\nCalculates div(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_rem","page":"Checked Math","title":"Base.Checked.checked_rem","text":"Base.checked_rem(x, y)\n\nCalculates x%y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_fld","page":"Checked Math","title":"Base.Checked.checked_fld","text":"Base.checked_fld(x, y)\n\nCalculates fld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_mod","page":"Checked Math","title":"Base.Checked.checked_mod","text":"Base.checked_mod(x, y)\n\nCalculates mod(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.checked_cld","page":"Checked Math","title":"Base.Checked.checked_cld","text":"Base.checked_cld(x, y)\n\nCalculates cld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.add_with_overflow","page":"Checked Math","title":"Base.Checked.add_with_overflow","text":"Base.add_with_overflow(x, y) -> (r, f)\n\nCalculates r = x+y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.sub_with_overflow","page":"Checked Math","title":"Base.Checked.sub_with_overflow","text":"Base.sub_with_overflow(x, y) -> (r, f)\n\nCalculates r = x-y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Checked/#Base.Checked.mul_with_overflow","page":"Checked Math","title":"Base.Checked.mul_with_overflow","text":"Base.mul_with_overflow(x, y) -> (r, f)\n\nCalculates r = x*y, with the flag f indicating whether overflow has occurred.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Root/#Root","page":"Root","title":"Root","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/Root/","page":"Root","title":"Root","text":"Base.sqrt\nBase.isqrt\nBase.cbrt","category":"page"},{"location":"ElementaryMath/Exp-and-Log/Root/#Base.sqrt","page":"Root","title":"Base.sqrt","text":"sqrt(x)\n\nReturn sqrtx.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut along the negative real axis.\n\nThe prefix operator √ is equivalent to sqrt.\n\nSee also: hypot.\n\nExamples\n\njulia> sqrt(big(81))\n9.0\n\njulia> sqrt(big(-81))\nERROR: DomainError with -81.0:\nNaN result for non-NaN input.\nStacktrace:\n [1] sqrt(::BigFloat) at ./mpfr.jl:501\n[...]\n\njulia> sqrt(big(complex(-81)))\n0.0 + 9.0im\n\njulia> sqrt(-81 - 0.0im)  # -0.0im is below the branch cut\n0.0 - 9.0im\n\njulia> .√(1:4)\n4-element Vector{Float64}:\n 1.0\n 1.4142135623730951\n 1.7320508075688772\n 2.0\n\n\n\n\n\nsqrt(A::AbstractMatrix)\n\nIf A has no negative real eigenvalues, compute the principal matrix square root of A, that is the unique matrix X with eigenvalues having positive real part such that X^2 = A. Otherwise, a nonprincipal square root is returned.\n\nIf A is real-symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the square root.   For such matrices, eigenvalues λ that appear to be slightly negative due to roundoff errors are treated as if they were zero. More precisely, matrices with all eigenvalues ≥ -rtol*(max |λ|) are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. rtol is a keyword argument to sqrt (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by size(A,1).\n\nOtherwise, the square root is determined by means of the Björck-Hammarling method [BH83], which computes the complex Schur form (schur) and then the complex square root of the triangular factor. If a real square root exists, then an extension of this method [H87] that computes the real Schur form and then the real square root of the quasi-triangular factor is instead used.\n\n[BH83]: Åke Björck and Sven Hammarling, \"A Schur method for the square root of a matrix\", Linear Algebra and its Applications, 52-53, 1983, 127-140. doi:10.1016/0024-3795(83)80010-X\n\n[H87]: Nicholas J. Higham, \"Computing real square roots of a real matrix\", Linear Algebra and its Applications, 88-89, 1987, 405-430. doi:10.1016/0024-3795(87)90118-2\n\nExamples\n\njulia> A = [4 0; 0 4]\n2×2 Matrix{Int64}:\n 4  0\n 0  4\n\njulia> sqrt(A)\n2×2 Matrix{Float64}:\n 2.0  0.0\n 0.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Root/#Base.isqrt","page":"Root","title":"Base.isqrt","text":"isqrt(n::Integer)\n\nInteger square root: the largest integer m such that m*m <= n.\n\njulia> isqrt(5)\n2\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Root/#Base.Math.cbrt","page":"Root","title":"Base.Math.cbrt","text":"cbrt(x::Real)\n\nReturn the cube root of x, i.e. x^13. Negative values are accepted (returning the negative real root when x  0).\n\nThe prefix operator ∛ is equivalent to cbrt.\n\nExamples\n\njulia> cbrt(big(27))\n3.0\n\njulia> cbrt(big(-27))\n-3.0\n\n\n\n\n\ncbrt(A::AbstractMatrix{<:Real})\n\nComputes the real-valued cube root of a real-valued matrix A. If T = cbrt(A), then we have T*T*T ≈ A, see example given below.\n\nIf A is symmetric, i.e., of type HermOrSym{<:Real}, then (eigen) is used to find the cube root. Otherwise, a specialized version of the p-th root algorithm [S03] is utilized, which exploits the real-valued Schur decomposition (schur) to compute the cube root.\n\n[S03]: Matthew I. Smith, \"A Schur Algorithm for Computing Matrix pth Roots\", SIAM Journal on Matrix Analysis and Applications, vol. 24, 2003, pp. 971–989. doi:10.1137/S0895479801392697\n\nExamples\n\njulia> A = [0.927524 -0.15857; -1.3677 -1.01172]\n2×2 Matrix{Float64}:\n  0.927524  -0.15857\n -1.3677    -1.01172\n\njulia> T = cbrt(A)\n2×2 Matrix{Float64}:\n  0.910077  -0.151019\n -1.30257   -0.936818\n\njulia> T*T*T ≈ A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Tangent","page":"Tangent","title":"Tangent","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Tangent/","page":"Tangent","title":"Tangent","text":"Base.tan\nBase.tand\nBase.tanpi\nBase.tanh\nBase.atan\nBase.atand\nBase.atanh","category":"page"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.tan","page":"Tangent","title":"Base.tan","text":"tan(x)\n\nCompute tangent of x, where x is in radians.\n\n\n\n\n\ntan(A::AbstractMatrix)\n\nCompute the matrix tangent of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise, the tangent is determined by calling exp.\n\nExamples\n\njulia> tan(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n -1.09252  -1.09252\n -1.09252  -1.09252\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.Math.tand","page":"Tangent","title":"Base.Math.tand","text":"tand(x)\n\nCompute tangent of x, where x is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.Math.tanpi","page":"Tangent","title":"Base.Math.tanpi","text":"tanpi(x)\n\nCompute tan(pi x) more accurately than tan(pi*x), especially for large x.\n\ncompat: Julia 1.10\nThis function requires at least Julia 1.10.\n\nSee also tand, sinpi, cospi, sincospi.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.tanh","page":"Tangent","title":"Base.tanh","text":"tanh(x)\n\nCompute hyperbolic tangent of x.\n\nSee also tan, atanh.\n\nExamples\n\njulia> tanh.(-3:3f0)  # Here 3f0 isa Float32\n7-element Vector{Float32}:\n -0.9950548\n -0.9640276\n -0.7615942\n  0.0\n  0.7615942\n  0.9640276\n  0.9950548\n\njulia> tan.(im .* (1:3))\n3-element Vector{ComplexF64}:\n 0.0 + 0.7615941559557649im\n 0.0 + 0.9640275800758169im\n 0.0 + 0.9950547536867306im\n\n\n\n\n\ntanh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic tangent of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.atan","page":"Tangent","title":"Base.atan","text":"atan(y)\natan(y, x)\n\nCompute the inverse tangent of y or y/x, respectively.\n\nFor one real argument, this is the angle in radians between the positive x-axis and the point (1, y), returning a value in the interval -pi2 pi2.\n\nFor two arguments, this is the angle in radians between the positive x-axis and the point (x, y), returning a value in the interval -pi pi. This corresponds to a standard atan2 function. Note that by convention atan(0.0,x) is defined as pi and atan(-0.0,x) is defined as -pi when x < 0.\n\nSee also atand for degrees.\n\nExamples\n\njulia> rad2deg(atan(-1/√3))\n-30.000000000000004\n\njulia> rad2deg(atan(-1, √3))\n-30.000000000000004\n\njulia> rad2deg(atan(1, -√3))\n150.0\n\n\n\n\n\natan(A::AbstractMatrix)\n\nCompute the inverse matrix tangent of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using log.  For the theory and logarithmic formulas used to compute this function, see [AH16_3].\n\n[AH16_3]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\nExamples\n\njulia> atan(tan([0.5 0.1; -0.2 0.3]))\n2×2 Matrix{ComplexF64}:\n  0.5+1.38778e-17im  0.1-2.77556e-17im\n -0.2+6.93889e-17im  0.3-4.16334e-17im\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.Math.atand","page":"Tangent","title":"Base.Math.atand","text":"atand(y)\natand(y,x)\n\nCompute the inverse tangent of y or y/x, respectively, where the output is in degrees.\n\ncompat: Julia 1.7\nThe one-argument method supports square matrix arguments as of Julia 1.7.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Tangent/#Base.atanh","page":"Tangent","title":"Base.atanh","text":"atanh(x)\n\nCompute the inverse hyperbolic tangent of x.\n\n\n\n\n\natanh(A::AbstractMatrix)\n\nCompute the inverse hyperbolic matrix tangent of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_6].\n\n[AH16_6]: Mary Aprahamian and Nicholas J. Higham, \"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Power/#Power","page":"Power","title":"Power","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/Power/","page":"Power","title":"Power","text":"Base.ispow2\nBase.prevpow\nBase.nextpow\nBase.powermod","category":"page"},{"location":"ElementaryMath/Exp-and-Log/Power/#Base.ispow2","page":"Power","title":"Base.ispow2","text":"ispow2(n::Number) -> Bool\n\nTest whether n is an integer power of two.\n\nSee also count_ones, prevpow, nextpow.\n\nExamples\n\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n\njulia> ispow2(4.5)\nfalse\n\njulia> ispow2(0.25)\ntrue\n\njulia> ispow2(1//8)\ntrue\n\ncompat: Julia 1.6\nSupport for non-Integer arguments was added in Julia 1.6.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Power/#Base.prevpow","page":"Power","title":"Base.prevpow","text":"prevpow(a, x)\n\nThe largest a^n not greater than x, where n is a non-negative integer. a must be greater than 1, and x must not be less than 1.\n\nSee also nextpow, isqrt.\n\nExamples\n\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Power/#Base.nextpow","page":"Power","title":"Base.nextpow","text":"nextpow(a, x)\n\nThe smallest a^n not less than x, where n is a non-negative integer. a must be greater than 1, and x must be greater than 0.\n\nSee also prevpow.\n\nExamples\n\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/Power/#Base.powermod","page":"Power","title":"Base.powermod","text":"powermod(x::Integer, p::Integer, m)\n\nCompute x^p pmod m.\n\nExamples\n\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Hypotenuse/#Hypotenuse","page":"Hypotenuse","title":"Hypotenuse","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Hypotenuse/","page":"Hypotenuse","title":"Hypotenuse","text":"Base.hypot","category":"page"},{"location":"ElementaryMath/Trigonometry/Hypotenuse/#Base.Math.hypot","page":"Hypotenuse","title":"Base.Math.hypot","text":"hypot(x, y)\n\nCompute the hypotenuse sqrtx^2+y^2 avoiding overflow and underflow.\n\nThis code is an implementation of the algorithm described in: An Improved Algorithm for hypot(a,b) by Carlos F. Borges The article is available online at arXiv at the link   https://arxiv.org/abs/1904.09481\n\nhypot(x...)\n\nCompute the hypotenuse sqrtsum x_i^2 avoiding overflow and underflow.\n\nSee also norm in the LinearAlgebra standard library.\n\nExamples\n\njulia> a = Int64(10)^10;\n\njulia> hypot(a, a)\n1.4142135623730951e10\n\njulia> √(a^2 + a^2) # a^2 overflows\nERROR: DomainError with -2.914184810805068e18:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\njulia> hypot(3, 4im)\n5.0\n\njulia> hypot(-5.7)\n5.7\n\njulia> hypot(3, 4im, 12.0)\n13.0\n\njulia> using LinearAlgebra\n\njulia> norm([a, a, a, a]) == hypot(a, a, a, a)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Cosecant","page":"Cosecant","title":"Cosecant","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosecant/","page":"Cosecant","title":"Cosecant","text":"Base.csc\nBase.cscd\nBase.csch\nBase.acsc\nBase.acscd\nBase.acsch","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.csc","page":"Cosecant","title":"Base.Math.csc","text":"csc(x)\n\nCompute the cosecant of x, where x is in radians.\n\n\n\n\n\ncsc(A::AbstractMatrix)\n\nCompute the matrix cosecant of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.cscd","page":"Cosecant","title":"Base.Math.cscd","text":"cscd(x)\n\nCompute the cosecant of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.csch","page":"Cosecant","title":"Base.Math.csch","text":"csch(x)\n\nCompute the hyperbolic cosecant of x.\n\n\n\n\n\ncsch(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosecant of square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.acsc","page":"Cosecant","title":"Base.Math.acsc","text":"acsc(x)\n\nCompute the inverse cosecant of x, where the output is in radians. \n\n\n\n\n\nacsc(A::AbstractMatrix)\n\nCompute the inverse matrix cosecant of A. \n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.acscd","page":"Cosecant","title":"Base.Math.acscd","text":"acscd(x)\n\nCompute the inverse cosecant of x, where the output is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosecant/#Base.Math.acsch","page":"Cosecant","title":"Base.Math.acsch","text":"acsch(x)\n\nCompute the inverse hyperbolic cosecant of x. \n\n\n\n\n\nacsch(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cosecant of A. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TheMissingDoc4Julia","category":"page"},{"location":"#The-Missing-Doc-for-Julia","page":"Home","title":"The Missing Doc for Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Exploring how to organize docs better.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for inkydragon/TheMissingDoc4Julia.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project is intended to be a supplement to the official julia documentation. When possible, much of the project will be merged into the julia documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project is a reference.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reference guides are technical descriptions of the machinery and how to operate it. Reference material is information-oriented.—— 🔗Reference - diataxis.fr","category":"page"},{"location":"#Chinese-Doc","page":"Home","title":"Chinese Doc","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're a Chinese user of Julia, you might want to check:","category":"page"},{"location":"","page":"Home","title":"Home","text":"如果你是一个 Julia 的中文用户，你可能想要看看：","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia 中文文档 | JuliaCN\nSyslab 使用手册 | tongyuan.cc","category":"page"},{"location":"#Related-Julia-Issues","page":"Home","title":"Related Julia Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Separate documentation page for all function (🔗JuliaLang/julia#29552)\nAuto-generated separate reference pages for Julia objects / docstrings (🔗JuliaDocs/Documenter.jl#2133)","category":"page"},{"location":"Mathematics/#Mathematics","page":"Mathematics","title":"Mathematics","text":"","category":"section"},{"location":"Mathematics/#Elementary-Math","page":"Mathematics","title":"Elementary Math","text":"","category":"section"},{"location":"Mathematics/","page":"Mathematics","title":"Mathematics","text":"Arithmetic Operations\nTrigonometry\nExponents and Logarithms\nComplex Numbers\nDiscrete Math\nPolynomials\nSpecial Functions\nConstants","category":"page"},{"location":"Mathematics/#Stdlib","page":"Mathematics","title":"Stdlib","text":"","category":"section"},{"location":"Mathematics/","page":"Mathematics","title":"Mathematics","text":"Random Numbers\nLinear Algebra\nSparse Arrays","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Function-Index","page":"Function Index","title":"Function Index","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"See Also: Functions List - SpecialFunctions.jl","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"By default, all functions are provided by SpecialFunctions.jl.\n❌: means not implemented","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Gamma-Functions","page":"Function Index","title":"Gamma Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Gamma Function - DLMF\nIncomplete Gamma and Related Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\ngamma(z) gamma function\nloggamma(x) log(gamma(x))\nlogabsgamma(x) log(abs(gamma(x)))\ndigamma(x) derivative of loggamma\ntrigamma(x) second derivative of loggamma\npolygamma(m,x) (m+1)-th derivative of the loggamma\ngamma(a,z) incomplete gamma function\nloggamma(a,z) log(gamma(a,x))\ngamma_inc(a,x) incomplete gamma function\ngamma_inc_inv(a,p,q) inverse of the incomplete gamma function","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Beta-Functions","page":"Function Index","title":"Beta Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\nbeta(x,y) beta function\nlogbeta(x,y) log(beta(x,y))\nlogabsbeta(x,y) log(abs(beta(x,y)))\nbeta_inc(a,b,x,y) incomplete beta function\nbeta_inc_inv(a,b,p,q) inverse of the incomplete beta function","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Exponential-and-Trigonometric-Integrals","page":"Function Index","title":"Exponential and Trigonometric Integrals","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Exponential, Logarithmic, Sine, and Cosine Integrals - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\nexpint(ν, z) exponential integral  operatornameE_nu(z)\nexpinti(x) exponential integral  operatornameEi(x)\nexpintx(x) scaled exponential integral  e^z operatornameE_nu(z)\nsinint(x) sine integral  operatornameSi(x)\ncosint(x) cosine integral  operatornameCi(x)\nsinhint(x) ❌ hyperbolic sine integral  operatornameShi(x)\ncoshint(x) ❌ hyperbolic cosine integral  operatornameChi(x)","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Error-Functions,-Dawson’s-and-Fresnel-Integrals","page":"Function Index","title":"Error Functions, Dawson’s and Fresnel Integrals","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Error Functions, Dawson’s and Fresnel Integrals - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\nerf(x) error function at x\nerf(x,y) accurate version of operatornameerf(y) - operatornameerf(x)\nerfc(x) complementary error function, i.e. the accurate version of 1-operatornameerf(x) for large x\nerfcinv(x) inverse function to erfc()\nerfcx(x) scaled complementary error function, i.e. accurate e^x^2 operatornameerfc(x) for large x\nlogerfc(x) log of the complementary error function, i.e. accurate operatornameln(operatornameerfc(x)) for large x\nlogerfcx(x) log of the scaled complementary error function, i.e. accurate operatornameln(operatornameerfcx(x)) for large negative x\nerfi(x) imaginary error function defined as -i operatornameerf(ix)\nerfinv(x) inverse function to erf()\ndawson(x) scaled imaginary error function, a.k.a. Dawson function, i.e. accurate fracsqrtpi2 e^-x^2 operatornameerfi(x) for large x\nfaddeeva(x) Faddeeva function, equivalent to operatornameerfcx(-ix)","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Airy-Functions","page":"Function Index","title":"Airy Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Airy and Related Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\nairyai(z) Airy Ai function at z\nairyaiprime(z) derivative of the Airy Ai function at z\nairybi(z) Airy Bi function at z\nairybiprime(z) derivative of the Airy Bi function at z\nairyaix(z) scaled Airy Ai function and derivative at z\nairyaiprimex(z) scaled Airy Ai function and derivative at z\nairybix(z) scaled Airy Ai function and derivative at z\nairybiprimex(z) scaled Airy Ai function and derivative at z","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Bessel-Functions","page":"Function Index","title":"Bessel Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Bessel Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"SpecialFunctions.jl\nJuliaMath/Bessels.jl: Bessel functions for real arguments and orders\nJuliaMath/FunctionZeros.jl: Zeros of Bessel J and Y functions\ncgeoga/BesselK.jl: An AD-compatible modified second-kind Bessel function.","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Struve-Functions","page":"Function Index","title":"Struve Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Struve and Related Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"MartinMikkelsen/FewSpecialFunctions.jl     Few special functions in Julia.   Includes ..., Struve function, ...\ngwater/Struve.jl     Struve functions for Julia","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Parabolic-Cylinder-Functions","page":"Function Index","title":"Parabolic Cylinder Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Parabolic Cylinder Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"MartinMikkelsen/FewSpecialFunctions.jl     Few special functions in Julia.   Includes ..., Parabolic cylinder function","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Confluent-Hypergeometric-Functions","page":"Function Index","title":"Confluent Hypergeometric Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Confluent Hypergeometric Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"MartinMikkelsen/FewSpecialFunctions.jl     Few special functions in Julia.   Includes Clausen function, Coulomb wave functions, Debye function,   Fresnel functions, Struve function, Hypergeometric functions,   Confluent hypergeometric functions, Fermi-Dirac","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Legendre-Functions","page":"Function Index","title":"Legendre Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Legendre and Related Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"JuliaSpace/SatelliteToolboxLegendre.jl     Methods to compute Legendre associated functions and their derivatives.\njmert/AssociatedLegendrePolynomials.jl     A library for calculating the Associated Legendre polynomials","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Hypergeometric-Function","page":"Function Index","title":"Hypergeometric Function","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Hypergeometric Function - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"JuliaMath/HypergeometricFunctions.jl     A Julia package for calculating hypergeometric functions\nMartinMikkelsen/FewSpecialFunctions.jl     Few special functions in Julia.   Includes Clausen function, Coulomb wave functions, Debye function,   Fresnel functions, Struve function, Hypergeometric functions,   Confluent hypergeometric functions, Fermi-Dirac","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Elliptic-Integrals","page":"Function Index","title":"Elliptic Integrals","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Elliptic Integrals - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\nellipk(m) complete elliptic integral of 1st kind K(m)\nellipe(m) complete elliptic integral of 2nd kind E(m)","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Zeta-Functions","page":"Function Index","title":"Zeta Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Zeta and Related Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Function Description\neta(x) Dirichlet eta function at x\nzeta(x) Riemann zeta function at x","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Mathieu-Functions","page":"Function Index","title":"Mathieu Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Mathieu Functions and Hill’s Equation - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"BBN-Q/MathieuFunctions.jl     Julia package for Mathieu Functions\nLightup1/MathieuF.jl     Julia package for Mathieu Functions with function forms similar to   Mathieu related functions in Mathematica.\njebej/Mathieu.jl   Package for computing Mathieu functions and characteristic values","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Spheroidal-Wave-Functions","page":"Function Index","title":"Spheroidal Wave Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Spheroidal Wave Functions - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"missing","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/#Other-Special-Functions","page":"Function Index","title":"Other Special Functions","text":"","category":"section"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"Lambert W-Function - DLMF","category":"page"},{"location":"ElementaryMath/SpecialFunctions/functions/","page":"Function Index","title":"Function Index","text":"JuliaMath/LambertW.jl","category":"page"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/#Multiplication","page":"Multiplication","title":"Multiplication","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/","page":"Multiplication","title":"Multiplication","text":"Base.:*(::Any, ::Any...)\nBase.prod\nBase.cumprod\nBase.cumprod!","category":"page"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/#Base.:*-Tuple{Any, Vararg{Any}}","page":"Multiplication","title":"Base.:*","text":"*(x, y...)\n\nMultiplication operator.\n\nInfix x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...), which by default then calls (x*y) * z * ... starting from the left.\n\nJuxtaposition such as 2pi also calls *(2, pi). Note that this operation has higher precedence than a literal *. Note also that juxtaposition \"0x...\" (integer zero times a variable whose name starts with x) is forbidden as it clashes with unsigned integer literals: 0x01 isa UInt8.\n\nNote that overflow is possible for most integer types, including the default Int, when multiplying large numbers.\n\nExamples\n\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n\njulia> [2 0; 0 3] * [1, 10]  # matrix * vector\n2-element Vector{Int64}:\n  2\n 30\n\njulia> 1/2pi, 1/2*pi  # juxtaposition has higher precedence\n(0.15915494309189535, 1.5707963267948966)\n\njulia> x = [1, 2]; x'x  # adjoint vector * vector\n5\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/#Base.prod","page":"Multiplication","title":"Base.prod","text":"prod(f, itr; [init])\n\nReturn the product of f applied to each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the multiplicative identity (i.e. one) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> prod(abs2, [2; 3; 4])\n576\n\n\n\n\n\nprod(itr; [init])\n\nReturn the product of all elements of a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the multiplicative identity (i.e. one) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nSee also: reduce, cumprod, any.\n\nExamples\n\njulia> prod(1:5)\n120\n\njulia> prod(1:5; init = 1.0)\n120.0\n\n\n\n\n\nprod(A::AbstractArray; dims)\n\nMultiply elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(A, dims=1)\n1×2 Matrix{Int64}:\n 3  8\n\njulia> prod(A, dims=2)\n2×1 Matrix{Int64}:\n  2\n 12\n\n\n\n\n\nprod(f, A::AbstractArray; dims)\n\nMultiply the results of calling the function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 9  64\n\njulia> prod(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n   4\n 144\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/#Base.cumprod","page":"Multiplication","title":"Base.cumprod","text":"cumprod(A; dims::Integer)\n\nCumulative product along the dimension dim. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = Int8[1 2 3; 4 5 6];\n\njulia> cumprod(a, dims=1)\n2×3 Matrix{Int64}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a, dims=2)\n2×3 Matrix{Int64}:\n 1   2    6\n 4  20  120\n\n\n\n\n\ncumprod(itr)\n\nCumulative product of an iterator.\n\nSee also cumprod!, accumulate, cumsum.\n\ncompat: Julia 1.5\ncumprod on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumprod(fill(1//2, 3))\n3-element Vector{Rational{Int64}}:\n 1//2\n 1//4\n 1//8\n\njulia> cumprod((1, 2, 1, 3, 1))\n(1, 2, 2, 6, 6)\n\njulia> cumprod(\"julia\")\n5-element Vector{String}:\n \"j\"\n \"ju\"\n \"jul\"\n \"juli\"\n \"julia\"\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Multiplication/Multiplication/#Base.cumprod!","page":"Multiplication","title":"Base.cumprod!","text":"cumprod!(B, A; dims::Integer)\n\nCumulative product of A along the dimension dims, storing the result in B. See also cumprod.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\ncumprod!(y::AbstractVector, x::AbstractVector)\n\nCumulative product of a vector x, storing the result in y. See also cumprod.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Complex-Numbers","page":"Complex Numbers","title":"Complex Numbers","text":"","category":"section"},{"location":"ElementaryMath/Complex/Complex/","page":"Complex Numbers","title":"Complex Numbers","text":"abs\nabs2\ncomplex\nim\nreal\nimag\nreim\nconj\nangle\nisreal","category":"page"},{"location":"ElementaryMath/Complex/Complex/#Sign","page":"Complex Numbers","title":"Sign","text":"","category":"section"},{"location":"ElementaryMath/Complex/Complex/","page":"Complex Numbers","title":"Complex Numbers","text":"sign\nsignbit\nflipsign\ncopysign","category":"page"},{"location":"ElementaryMath/Complex/Complex/","page":"Complex Numbers","title":"Complex Numbers","text":"Base.abs\nBase.abs2\n\nBase.complex\nBase.im\n\nBase.real\nBase.imag\nBase.reim\nBase.conj\nBase.angle\n\nBase.isreal\nBase.sign\nBase.signbit\nBase.flipsign\nBase.copysign","category":"page"},{"location":"ElementaryMath/Complex/Complex/#Base.abs","page":"Complex Numbers","title":"Base.abs","text":"abs(x)\n\nThe absolute value of x.\n\nWhen abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x < 0, not -x as might be expected.\n\nSee also: abs2, unsigned, sign.\n\nExamples\n\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs.(Int8[-128 -127 -126 0 126 127])  # overflow at typemin(Int8)\n1×6 Matrix{Int8}:\n -128  127  126  0  126  127\n\njulia> maximum(abs, [1, -2, 3, -4])\n4\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.abs2","page":"Complex Numbers","title":"Base.abs2","text":"abs2(x)\n\nSquared absolute value of x.\n\nThis can be faster than abs(x)^2, especially for complex numbers where abs(x) requires a square root via hypot.\n\nSee also abs, conj, real.\n\nExamples\n\njulia> abs2(-3)\n9\n\njulia> abs2(3.0 + 4.0im)\n25.0\n\njulia> sum(abs2, [1+2im, 3+4im])  # LinearAlgebra.norm(x)^2\n30\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.complex","page":"Complex Numbers","title":"Base.complex","text":"complex(r, [i])\n\nConvert real numbers or arrays to complex. i defaults to zero.\n\nExamples\n\njulia> complex(7)\n7 + 0im\n\njulia> complex([1, 2, 3])\n3-element Vector{Complex{Int64}}:\n 1 + 0im\n 2 + 0im\n 3 + 0im\n\n\n\n\n\ncomplex(T::Type)\n\nReturn an appropriate type which can represent a value of type T as a complex number. Equivalent to typeof(complex(zero(T))) if T does not contain Missing.\n\nExamples\n\njulia> complex(Complex{Int})\nComplex{Int64}\n\njulia> complex(Int)\nComplex{Int64}\n\njulia> complex(Union{Int, Missing})\nUnion{Missing, Complex{Int64}}\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.im","page":"Complex Numbers","title":"Base.im","text":"im\n\nThe imaginary unit.\n\nSee also: imag, angle, complex.\n\nExamples\n\njulia> im * im\n-1 + 0im\n\njulia> (2.0 + 3im)^2\n-5.0 + 12.0im\n\n\n\n\n\n","category":"constant"},{"location":"ElementaryMath/Complex/Complex/#Base.real","page":"Complex Numbers","title":"Base.real","text":"real(z)\n\nReturn the real part of the complex number z.\n\nSee also: imag, reim, complex, isreal, Real.\n\nExamples\n\njulia> real(1 + 3im)\n1\n\n\n\n\n\nreal(T::Type)\n\nReturn the type that represents the real part of a value of type T. e.g: for T == Complex{R}, returns R. Equivalent to typeof(real(zero(T))).\n\nExamples\n\njulia> real(Complex{Int})\nInt64\n\njulia> real(Float64)\nFloat64\n\n\n\n\n\nreal(A::AbstractArray)\n\nReturn an array containing the real part of each entry in array A.\n\nEquivalent to real.(A), except that when eltype(A) <: Real A is returned without copying, and that when A has zero dimensions, a 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> real([1, 2im, 3 + 4im])\n3-element Vector{Int64}:\n 1\n 0\n 3\n\njulia> real(fill(2 - im))\n0-dimensional Array{Int64, 0}:\n2\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.imag","page":"Complex Numbers","title":"Base.imag","text":"imag(z)\n\nReturn the imaginary part of the complex number z.\n\nSee also: conj, reim, adjoint, angle.\n\nExamples\n\njulia> imag(1 + 3im)\n3\n\n\n\n\n\nimag(A::AbstractArray)\n\nReturn an array containing the imaginary part of each entry in array A.\n\nEquivalent to imag.(A), except that when A has zero dimensions, a 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> imag([1, 2im, 3 + 4im])\n3-element Vector{Int64}:\n 0\n 2\n 4\n\njulia> imag(fill(2 - im))\n0-dimensional Array{Int64, 0}:\n-1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.reim","page":"Complex Numbers","title":"Base.reim","text":"reim(z)\n\nReturn a tuple of the real and imaginary parts of the complex number z.\n\nExamples\n\njulia> reim(1 + 3im)\n(1, 3)\n\n\n\n\n\nreim(A::AbstractArray)\n\nReturn a tuple of two arrays containing respectively the real and the imaginary part of each entry in A.\n\nEquivalent to (real.(A), imag.(A)), except that when eltype(A) <: Real A is returned without copying to represent the real part, and that when A has zero dimensions, a 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> reim([1, 2im, 3 + 4im])\n([1, 0, 3], [0, 2, 4])\n\njulia> reim(fill(2 - im))\n(fill(2), fill(-1))\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.conj","page":"Complex Numbers","title":"Base.conj","text":"conj(z)\n\nCompute the complex conjugate of a complex number z.\n\nSee also: angle, adjoint.\n\nExamples\n\njulia> conj(1 + 3im)\n1 - 3im\n\n\n\n\n\nconj(A::AbstractArray)\n\nReturn an array containing the complex conjugate of each entry in array A.\n\nEquivalent to conj.(A), except that when eltype(A) <: Real A is returned without copying, and that when A has zero dimensions, a 0-dimensional array is returned (rather than a scalar).\n\nExamples\n\njulia> conj([1, 2im, 3 + 4im])\n3-element Vector{Complex{Int64}}:\n 1 + 0im\n 0 - 2im\n 3 - 4im\n\njulia> conj(fill(2 - im))\n0-dimensional Array{Complex{Int64}, 0}:\n2 + 1im\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.angle","page":"Complex Numbers","title":"Base.angle","text":"angle(z)\n\nCompute the phase angle in radians of a complex number z.\n\nReturns a number -pi ≤ angle(z) ≤ pi, and is thus discontinuous along the negative real axis.\n\nSee also: atan, cis, rad2deg.\n\nExamples\n\njulia> rad2deg(angle(1 + im))\n45.0\n\njulia> rad2deg(angle(1 - im))\n-45.0\n\njulia> rad2deg(angle(-1 + 1e-20im))\n180.0\n\njulia> rad2deg(angle(-1 - 1e-20im))\n-180.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.isreal","page":"Complex Numbers","title":"Base.isreal","text":"isreal(x) -> Bool\n\nTest whether x or all its elements are numerically equal to some real number including infinities and NaNs. isreal(x) is true if isequal(x, real(x)) is true.\n\nExamples\n\njulia> isreal(5.)\ntrue\n\njulia> isreal(1 - 3im)\nfalse\n\njulia> isreal(Inf + 0im)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.sign","page":"Complex Numbers","title":"Base.sign","text":"sign(x)\n\nReturn zero if x==0 and xx otherwise (i.e., ±1 for real x).\n\nSee also signbit, zero, copysign, flipsign.\n\nExamples\n\njulia> sign(-4.0)\n-1.0\n\njulia> sign(99)\n1\n\njulia> sign(-0.0)\n-0.0\n\njulia> sign(0 + im)\n0.0 + 1.0im\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.signbit","page":"Complex Numbers","title":"Base.signbit","text":"signbit(x)\n\nReturn true if the value of the sign of x is negative, otherwise false.\n\nSee also sign and copysign.\n\nExamples\n\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.flipsign","page":"Complex Numbers","title":"Base.flipsign","text":"flipsign(x, y)\n\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\n\nExamples\n\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Complex/Complex/#Base.copysign","page":"Complex Numbers","title":"Base.copysign","text":"copysign(x, y) -> z\n\nReturn z which has the magnitude of x and the same sign as y.\n\nExamples\n\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/SinCos/cis/#cis","page":"cis","title":"cis","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/SinCos/cis/","page":"cis","title":"cis","text":"Base.cis","category":"page"},{"location":"ElementaryMath/Trigonometry/SinCos/cis/#Base.cis","page":"cis","title":"Base.cis","text":"cis(x)\n\nMore efficient method for exp(im*x) by using Euler's formula: cos(x) + i sin(x) = exp(i x).\n\nSee also cispi, sincos, exp, angle.\n\nExamples\n\njulia> cis(π) ≈ -1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#sin","page":"sin","title":"sin","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"Compute sine of parameter in radians.","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"using LinearAlgebra","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"Base.sin","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Base.sin","page":"sin","title":"Base.sin","text":"sin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n\njulia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1×9 Matrix{Float64}:\n 0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n\njulia> sind(45)\n0.7071067811865476\n\njulia> sinpi(1/4)\n0.7071067811865475\n\njulia> round.(sincos(pi/6), digits=3)\n(0.5, 0.866)\n\njulia> round(cis(pi/6), digits=3)\n0.866 + 0.5im\n\njulia> round(exp(im*pi/6), digits=3)\n0.866 + 0.5im\n\n\n\n\n\nsin(A::AbstractMatrix)\n\nCompute the matrix sine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the sine. Otherwise, the sine is determined by calling exp.\n\nExamples\n\njulia> sin(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n 0.454649  0.454649\n 0.454649  0.454649\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Methods","page":"sin","title":"Methods","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"methods(sin, (Any,), [Base, Base.Math, Base.MathConstants, Base.MPFR])","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Examples","page":"sin","title":"Examples","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"using UnicodePlots\nlineplot(-π, π, sin)","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Real-Numbers","page":"sin","title":"Real Numbers","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"julia> sin(0)\n0.0\n\njulia> sin(0.5*pi)\n1.0\n\njulia> sin(pi)\n0.0\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> sin.([0 0.5*pi pi 1.5*pi 2*pi])\n1×5 Matrix{Float64}:\n 0.0  1.0  1.22465e-16  -1.0  -2.44929e-16","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"tip: dot-style function call\nf.(args) means eval args one by one.","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"big float, sin(pi/6) == sin(30°) == 1/2:","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"julia> sin(pi/6)\n0.49999999999999994\n\njulia> sin(pi/big\"6\")\n0.4999999999999999999999999999999999999999999999999999999999999999999999999999957","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"special float NaN, Inf:","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"julia> sin(NaN)\nNaN\n\njulia> sin(Inf)\nERROR: DomainError with Inf:\nsin(x) is only defined for finite x.\n[...]","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Complex","page":"sin","title":"Complex","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"julia> sin(0+0im)\n0.0 + 0.0im","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"plot real part","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"using UnicodePlots\nsin_real(x, y) = real(sin(x + y*im))\nsurfaceplot(-2pi:0.01:2pi, -pi:0.01:pi, sin_real)","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Tips","page":"sin","title":"Tips","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"Call sinpi to compute sin(x*pi)","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#See-Also","page":"sin","title":"See Also","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"sinpi, sincos, sind, sinh, asin","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Extended-Inputs","page":"sin","title":"Extended Inputs","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Matrix","page":"sin","title":"Matrix","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"With Array like input:","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"methods(sin, (Any,), [LinearAlgebra])","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"# TODO\nBase.sin(AbstractMatrix)","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"julia> sin([1 2; 3 4])\n2×2 Matrix{Float64}:\n -0.465581  -0.148424\n -0.222637  -0.688218\n\njulia> sin.([1 2; 3 4])\n2×2 Matrix{Float64}:\n 0.841471   0.909297\n 0.14112   -0.756802\n\njulia> sin([1 2; 3 4]) == sin.([1 2; 3 4])\nfalse","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Tech-Notes","page":"sin","title":"Tech Notes","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"sin(::Real): by pure julia\nsin(::BigFloat): by MPFR","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#Version-History","page":"sin","title":"Version History","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"Introduced in 2018 (1.0)","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sin/#External-Links","page":"sin","title":"External Links","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sin/","page":"sin","title":"sin","text":"🔗Sine - Wikipedia\n🔗Sine - MathWorld","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acosd/#acosd","page":"acosd","title":"acosd","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/acosd/","page":"acosd","title":"acosd","text":"Base.acosd","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/acosd/#Base.Math.acosd","page":"acosd","title":"Base.Math.acosd","text":"acosd(x)\n\nCompute the inverse cosine of x, where the output is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Sine/sinc/#sinc","page":"sinc","title":"sinc","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Sine/sinc/","page":"sinc","title":"sinc","text":"Base.sinc","category":"page"},{"location":"ElementaryMath/Trigonometry/Sine/sinc/#Base.Math.sinc","page":"sinc","title":"Base.Math.sinc","text":"sinc(x)\n\nCompute normalized sinc function operatornamesinc(x) = sin(pi x)  (pi x) if x neq 0, and 1 if x = 0.\n\nSee also cosc, its derivative.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Base/Types/","page":"Types","title":"Types","text":"TODO","category":"page"},{"location":"Base/Types/#Missing","page":"Types","title":"Missing","text":"","category":"section"},{"location":"Base/Types/","page":"Types","title":"Types","text":"Missing\nmissing\nismissing\nskipmissing\nnonmissingtype","category":"page"},{"location":"Base/Types/#Nothing","page":"Types","title":"Nothing","text":"","category":"section"},{"location":"Base/Types/","page":"Types","title":"Types","text":"Nothing\nnothing\nisnothing\nnotnothing\nSome\nsomething\n@something","category":"page"},{"location":"Base/Types/#Temp-docs","page":"Types","title":"Temp docs","text":"","category":"section"},{"location":"Base/Types/","page":"Types","title":"Types","text":"typeof\n# subtypes # in InteractiveUtils\nsupertype\nwiden\nisa\nCore.:(<:)\nBase.:(>:)\n\nisbits\nisconcretetype\nisabstracttype\nBase.issingletontype\nisinteger\n\ntypemax\ntypemin\nfloatmax\n\nMissing\nismissing\nskipmissing\nnonmissingtype\n\nNothing\nisnothing\nBase.notnothing\n\nSome\nsomething\n@something","category":"page"},{"location":"Base/Types/#Core.typeof","page":"Types","title":"Core.typeof","text":"typeof(x)\n\nGet the concrete type of x.\n\nSee also eltype.\n\nExamples\n\njulia> a = 1//2;\n\njulia> typeof(a)\nRational{Int64}\n\njulia> M = [1 2; 3.5 4];\n\njulia> typeof(M)\nMatrix{Float64} (alias for Array{Float64, 2})\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.supertype","page":"Types","title":"Base.supertype","text":"supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.widen","page":"Types","title":"Base.widen","text":"widen(x)\n\nIf x is a type, return a \"larger\" type, defined so that arithmetic operations + and - are guaranteed not to overflow nor lose precision for any combination of values that type x can hold.\n\nFor fixed-size integer types less than 128 bits, widen will return a type with twice the number of bits.\n\nIf x is a value, it is converted to widen(typeof(x)).\n\nExamples\n\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Core.isa","page":"Types","title":"Core.isa","text":"isa(x, type) -> Bool\n\nDetermine whether x is of the given type. Can also be used as an infix operator, e.g. x isa type.\n\nExamples\n\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, Matrix)\nfalse\n\njulia> isa(1, Char)\nfalse\n\njulia> isa(1, Number)\ntrue\n\njulia> 1 isa Number\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Core.:<:","page":"Types","title":"Core.:<:","text":"<:(T1, T2)\n\nSubtype operator: returns true if and only if all values of type T1 are also of type T2.\n\nExamples\n\njulia> Float64 <: AbstractFloat\ntrue\n\njulia> Vector{Int} <: AbstractArray\ntrue\n\njulia> Matrix{Float64} <: Matrix{AbstractFloat}\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.:>:","page":"Types","title":"Base.:>:","text":">:(T1, T2)\n\nSupertype operator, equivalent to T2 <: T1.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.isbits","page":"Types","title":"Base.isbits","text":"isbits(x)\n\nReturn true if x is an instance of an isbitstype type.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.isconcretetype","page":"Types","title":"Base.isconcretetype","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T). Note that this is not the negation of isabstracttype(T). If T is not a type, then return false.\n\nSee also: isbits, isabstracttype, issingletontype.\n\nExamples\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.isabstracttype","page":"Types","title":"Base.isabstracttype","text":"isabstracttype(T)\n\nDetermine whether type T was declared as an abstract type (i.e. using the abstract type syntax). Note that this is not the negation of isconcretetype(T). If T is not a type, then return false.\n\nExamples\n\njulia> isabstracttype(AbstractArray)\ntrue\n\njulia> isabstracttype(Vector)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.issingletontype","page":"Types","title":"Base.issingletontype","text":"Base.issingletontype(T)\n\nDetermine whether type T has exactly one possible instance; for example, a struct type with no fields except other singleton values. If T is not a concrete type, then return false.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.isinteger","page":"Types","title":"Base.isinteger","text":"isinteger(x) -> Bool\n\nTest whether x is numerically equal to some integer.\n\nExamples\n\njulia> isinteger(4.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.typemax","page":"Types","title":"Base.typemax","text":"typemax(T)\n\nThe highest value representable by the given (real) numeric DataType.\n\nSee also: floatmax, typemin, eps.\n\nExamples\n\njulia> typemax(Int8)\n127\n\njulia> typemax(UInt32)\n0xffffffff\n\njulia> typemax(Float64)\nInf\n\njulia> typemax(Float32)\nInf32\n\njulia> floatmax(Float32)  # largest finite Float32 floating point number\n3.4028235f38\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.typemin","page":"Types","title":"Base.typemin","text":"typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType T.\n\nSee also: floatmin, typemax, eps.\n\nExamples\n\njulia> typemin(Int8)\n-128\n\njulia> typemin(UInt32)\n0x00000000\n\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n\njulia> nextfloat(-Inf32)  # smallest finite Float32 floating point number\n-3.4028235f38\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.floatmax","page":"Types","title":"Base.floatmax","text":"floatmax(T = Float64)\n\nReturn the largest finite number representable by the floating-point type T.\n\nSee also: typemax, floatmin, eps.\n\nExamples\n\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmax(Float32)\n3.4028235f38\n\njulia> floatmax()\n1.7976931348623157e308\n\njulia> typemax(Float64)\nInf\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.Missing","page":"Types","title":"Base.Missing","text":"Missing\n\nA type with no fields whose singleton instance missing is used to represent missing values.\n\nSee also: skipmissing, nonmissingtype, Nothing.\n\n\n\n\n\n","category":"type"},{"location":"Base/Types/#Base.ismissing","page":"Types","title":"Base.ismissing","text":"ismissing(x)\n\nIndicate whether x is missing.\n\nSee also: skipmissing, isnothing, isnan.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.skipmissing","page":"Types","title":"Base.skipmissing","text":"skipmissing(itr)\n\nReturn an iterator over the elements in itr skipping missing values. The returned object can be indexed using indices of itr if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by keys and eachindex, and a MissingException is thrown when trying to use them.\n\nUse collect to obtain an Array containing the non-missing values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove missings while preserving dimensions of the input.\n\nSee also coalesce, ismissing, something.\n\nExamples\n\njulia> x = skipmissing([1, missing, 2])\nskipmissing(Union{Missing, Int64}[1, missing, 2])\n\njulia> sum(x)\n3\n\njulia> x[1]\n1\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\njulia> argmax(x)\n3\n\njulia> collect(keys(x))\n2-element Vector{Int64}:\n 1\n 3\n\njulia> collect(skipmissing([1, missing, 2]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(skipmissing([1 missing; 2 missing]))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.nonmissingtype","page":"Types","title":"Base.nonmissingtype","text":"nonmissingtype(T::Type)\n\nIf T is a union of types containing Missing, return a new type with Missing removed.\n\nExamples\n\njulia> nonmissingtype(Union{Int64,Missing})\nInt64\n\njulia> nonmissingtype(Any)\nAny\n\ncompat: Julia 1.3\nThis function is exported as of Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Core.Nothing","page":"Types","title":"Core.Nothing","text":"Nothing\n\nA type with no fields that is the type of nothing.\n\nSee also: isnothing, Some, Missing.\n\n\n\n\n\n","category":"type"},{"location":"Base/Types/#Base.isnothing","page":"Types","title":"Base.isnothing","text":"isnothing(x)\n\nReturn true if x === nothing, and return false if not.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nSee also something, Base.notnothing, ismissing.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.notnothing","page":"Types","title":"Base.notnothing","text":"notnothing(x)\n\nThrow an error if x === nothing, and return x if not.\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.Some","page":"Types","title":"Base.Some","text":"Some{T}\n\nA wrapper type used in Union{Some{T}, Nothing} to distinguish between the absence of a value (nothing) and the presence of a nothing value (i.e. Some(nothing)).\n\nUse something to access the value wrapped by a Some object.\n\n\n\n\n\n","category":"type"},{"location":"Base/Types/#Base.something","page":"Types","title":"Base.something","text":"something(x...)\n\nReturn the first value in the arguments which is not equal to nothing, if any. Otherwise throw an error. Arguments of type Some are unwrapped.\n\nSee also coalesce, skipmissing, @something.\n\nExamples\n\njulia> something(nothing, 1)\n1\n\njulia> something(Some(1), nothing)\n1\n\njulia> something(Some(nothing), 2) === nothing\ntrue\n\njulia> something(missing, nothing)\nmissing\n\njulia> something(nothing, nothing)\nERROR: ArgumentError: No value arguments present\n\n\n\n\n\n","category":"function"},{"location":"Base/Types/#Base.@something","page":"Types","title":"Base.@something","text":"@something(x...)\n\nShort-circuiting version of something.\n\nExamples\n\njulia> f(x) = (println(\"f($x)\"); nothing);\n\njulia> a = 1;\n\njulia> a = @something a f(2) f(3) error(\"Unable to find default for `a`\")\n1\n\njulia> b = nothing;\n\njulia> b = @something b f(2) f(3) error(\"Unable to find default for `b`\")\nf(2)\nf(3)\nERROR: Unable to find default for `b`\n[...]\n\njulia> b = @something b f(2) f(3) Some(nothing)\nf(2)\nf(3)\n\njulia> b === nothing\ntrue\n\ncompat: Julia 1.7\nThis macro is available as of Julia 1.7.\n\n\n\n\n\n","category":"macro"},{"location":"ElementaryMath/Trigonometry/Conversions/#Conversions","page":"Conversions","title":"Conversions","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Conversions/","page":"Conversions","title":"Conversions","text":"Base.rad2deg\nBase.deg2rad","category":"page"},{"location":"ElementaryMath/Trigonometry/Conversions/#Base.Math.rad2deg","page":"Conversions","title":"Base.Math.rad2deg","text":"rad2deg(x)\n\nConvert x from radians to degrees.\n\nSee also deg2rad.\n\nExamples\n\njulia> rad2deg(pi)\n180.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Conversions/#Base.Math.deg2rad","page":"Conversions","title":"Base.Math.deg2rad","text":"deg2rad(x)\n\nConvert x from degrees to radians.\n\nSee also rad2deg, sind, pi.\n\nExamples\n\njulia> deg2rad(90)\n1.5707963267948966\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Addition","page":"Addition","title":"Addition","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/","page":"Addition","title":"Addition","text":"Base.:(+)\nBase.sum\nBase.sum!\nBase.cumsum\nBase.cumsum!\nBase.add_sum","category":"page"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.:+","page":"Addition","title":"Base.:+","text":"+(x, y...)\n\nAddition operator.\n\nInfix x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...), which by default then calls (x+y) + z + ... starting from the left.\n\nNote that overflow is possible for most integer types, including the default Int, when adding large numbers.\n\nExamples\n\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n\njulia> [1,2] + [3,4]\n2-element Vector{Int64}:\n 4\n 6\n\njulia> typemax(Int) + 1 < 0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.sum","page":"Addition","title":"Base.sum","text":"sum(f, itr; [init])\n\nSum the results of calling function f on each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the additive identity (i.e. zero) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> sum(abs2, [2; 3; 4])\n29\n\nNote the important difference between sum(A) and reduce(+, A) for arrays with small integer eltype:\n\njulia> sum(Int8[100, 28])\n128\n\njulia> reduce(+, Int8[100, 28])\n-128\n\nIn the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.\n\n\n\n\n\nsum(itr; [init])\n\nReturn the sum of all elements in a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the additive identity (i.e. zero) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nSee also: reduce, mapreduce, count, union.\n\nExamples\n\njulia> sum(1:20)\n210\n\njulia> sum(1:20; init = 0.0)\n210.0\n\n\n\n\n\nsum(A::AbstractArray; dims)\n\nSum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(A, dims=1)\n1×2 Matrix{Int64}:\n 4  6\n\njulia> sum(A, dims=2)\n2×1 Matrix{Int64}:\n 3\n 7\n\n\n\n\n\nsum(f, A::AbstractArray; dims)\n\nSum the results of calling function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 10  20\n\njulia> sum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n  5\n 25\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.sum!","page":"Addition","title":"Base.sum!","text":"sum!(r, A)\n\nSum elements of A over the singleton dimensions of r, and write results to r.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Vector{Int64}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Matrix{Int64}:\n 4  6\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.cumsum","page":"Addition","title":"Base.cumsum","text":"cumsum(A; dims::Integer)\n\nCumulative sum along the dimension dims. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a, dims=1)\n2×3 Matrix{Int64}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a, dims=2)\n2×3 Matrix{Int64}:\n 1  3   6\n 4  9  15\n\nnote: Note\nThe return array's eltype is Int for signed integers of less than system word size  and UInt for unsigned integers of less than system word size. To preserve eltype of arrays with small signed or unsigned integer accumulate(+, A) should be used.julia> cumsum(Int8[100, 28])\n2-element Vector{Int64}:\n 100\n 128\n\njulia> accumulate(+,Int8[100, 28])\n2-element Vector{Int8}:\n  100\n -128In the former case, the integers are widened to system word size and therefore the result is Int64[100, 128]. In the latter case, no such widening happens and integer overflow results in Int8[100, -128].\n\n\n\n\n\ncumsum(itr)\n\nCumulative sum of an iterator.\n\nSee also accumulate to apply functions other than +.\n\ncompat: Julia 1.5\ncumsum on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumsum(1:3)\n3-element Vector{Int64}:\n 1\n 3\n 6\n\njulia> cumsum((true, false, true, false, true))\n(1, 1, 2, 2, 3)\n\njulia> cumsum(fill(1, 2) for i in 1:3)\n3-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 2]\n [3, 3]\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.cumsum!","page":"Addition","title":"Base.cumsum!","text":"cumsum!(B, A; dims::Integer)\n\nCumulative sum of A along the dimension dims, storing the result in B. See also cumsum.\n\nwarning: Warning\nBehavior can be unexpected when any mutated argument shares memory with any other argument.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Addition/Addition/#Base.add_sum","page":"Addition","title":"Base.add_sum","text":"Base.add_sum(x, y)\n\nThe reduction operator used in sum. The main difference from + is that small integers are promoted to Int/UInt.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/cosh/#cosh","page":"cosh","title":"cosh","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cosh/","page":"cosh","title":"cosh","text":"Base.cosh","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cosh/#Base.cosh","page":"cosh","title":"Base.cosh","text":"cosh(x)\n\nCompute hyperbolic cosine of x.\n\n\n\n\n\ncosh(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cosine of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Division/Division/#Division","page":"Division","title":"Division","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Division/Division/","page":"Division","title":"Division","text":"Base.:(/)\nBase.:\\(::Any, ::Any)\nBase.:(//)","category":"page"},{"location":"ElementaryMath/Arithmetic/Division/Division/#Base.:/","page":"Division","title":"Base.:/","text":"/(x, y)\n\nRight division operator: multiplication of x by the inverse of y on the right.\n\nGives floating-point results for integer arguments. See ÷ for integer division, or // for Rational results.\n\nExamples\n\njulia> 1/2\n0.5\n\njulia> 4/2\n2.0\n\njulia> 4.5/2\n2.25\n\n\n\n\n\nA / B\n\nMatrix right-division: A / B is equivalent to (B' \\ A')' where \\ is the left-division operator. For square matrices, the result X is such that A == X*B.\n\nSee also: rdiv!.\n\nExamples\n\njulia> A = Float64[1 4 5; 3 9 2]; B = Float64[1 4 2; 3 4 2; 8 7 1];\n\njulia> X = A / B\n2×3 Matrix{Float64}:\n -0.65   3.75  -1.2\n  3.25  -2.75   1.0\n\njulia> isapprox(A, X*B)\ntrue\n\njulia> isapprox(X, A*pinv(B))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Division/Division/#Base.:\\-Tuple{Any, Any}","page":"Division","title":"Base.:\\","text":"\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\n\nExamples\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [4 3; 2 1]; x = [5, 6];\n\njulia> A \\ x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\njulia> inv(A) * x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\n\n\n\n\n","category":"method"},{"location":"ElementaryMath/Arithmetic/Division/Division/#Base.://","page":"Division","title":"Base.://","text":"//(num, den)\n\nDivide two integers or rational numbers, giving a Rational result. More generally, // can be used for exact rational division of other numeric types with integer or rational components, such as complex numbers with integer components.\n\nNote that floating-point (AbstractFloat) arguments are not permitted by // (even if the values are rational). The arguments must be subtypes of Integer, Rational, or composites thereof.\n\nExamples\n\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n\njulia> (1+2im) // (3+4im)\n11//25 + 2//25*im\n\njulia> 1.0 // 2\nERROR: MethodError: no method matching //(::Float64, ::Int64)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Cotangent","page":"Cotangent","title":"Cotangent","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cotangent/","page":"Cotangent","title":"Cotangent","text":"Base.cot\nBase.cotd\nBase.coth\nBase.acot\nBase.acotd\nBase.acoth","category":"page"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.cot","page":"Cotangent","title":"Base.Math.cot","text":"cot(x)\n\nCompute the cotangent of x, where x is in radians.\n\n\n\n\n\ncot(A::AbstractMatrix)\n\nCompute the matrix cotangent of a square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.cotd","page":"Cotangent","title":"Base.Math.cotd","text":"cotd(x)\n\nCompute the cotangent of x, where x is in degrees.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.coth","page":"Cotangent","title":"Base.Math.coth","text":"coth(x)\n\nCompute the hyperbolic cotangent of x.\n\n\n\n\n\ncoth(A::AbstractMatrix)\n\nCompute the matrix hyperbolic cotangent of square matrix A.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.acot","page":"Cotangent","title":"Base.Math.acot","text":"acot(x)\n\nCompute the inverse cotangent of x, where the output is in radians. \n\n\n\n\n\nacot(A::AbstractMatrix)\n\nCompute the inverse matrix cotangent of A. \n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.acotd","page":"Cotangent","title":"Base.Math.acotd","text":"acotd(x)\n\nCompute the inverse cotangent of x, where the output is in degrees. If x is a matrix, x needs to be a square matrix.\n\ncompat: Julia 1.7\nMatrix arguments require Julia 1.7 or later.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cotangent/#Base.Math.acoth","page":"Cotangent","title":"Base.Math.acoth","text":"acoth(x)\n\nCompute the inverse hyperbolic cotangent of x. \n\n\n\n\n\nacoth(A::AbstractMatrix)\n\nCompute the inverse matrix hyperbolic cotangent of A. \n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/log/#Log","page":"Log","title":"Log","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/log/","page":"Log","title":"Log","text":"Base.log","category":"page"},{"location":"ElementaryMath/Exp-and-Log/log/#Base.log","page":"Log","title":"Base.log","text":"log(b,x)\n\nCompute the base b logarithm of x. Throws DomainError for negative Real arguments.\n\nExamples\n\njulia> log(4,8)\n1.5\n\njulia> log(4,2)\n0.5\n\njulia> log(-2, 3)\nERROR: DomainError with -2.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\njulia> log(2, -3)\nERROR: DomainError with -3.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\nnote: Note\nIf b is a power of 2 or 10, log2 or log10 should be used, as these will typically be faster and more accurate. For example,julia> log(100,1000000)\n2.9999999999999996\n\njulia> log10(1000000)/2\n3.0\n\n\n\n\n\nlog(x)\n\nCompute the natural logarithm of x.\n\nThrows DomainError for negative Real arguments. Use complex arguments to obtain complex results. Has a branch cut along the negative real axis, for which -0.0im is taken to be below the axis.\n\nSee also ℯ, log1p, log2, log10.\n\nExamples\n\njulia> log(2)\n0.6931471805599453\n\njulia> log(-3)\nERROR: DomainError with -3.0:\nlog was called with a negative real argument but will only return a complex result if called with a complex argument. Try log(Complex(x)).\nStacktrace:\n [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31\n[...]\n\njulia> log(-3 + 0im)\n1.0986122886681098 + 3.141592653589793im\n\njulia> log(-3 - 0.0im)\n1.0986122886681098 - 3.141592653589793im\n\njulia> log.(exp.(-1:1))\n3-element Vector{Float64}:\n -1.0\n  0.0\n  1.0\n\n\n\n\n\nlog(A::AbstractMatrix)\n\nIf A has no negative real eigenvalue, compute the principal matrix logarithm of A, i.e. the unique matrix X such that e^X = A and -pi  Im(lambda)  pi for all the eigenvalues lambda of X. If A has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used, if A is triangular an improved version of the inverse scaling and squaring method is employed (see [AH12] and [AHR13]). If A is real with no negative eigenvalues, then the real Schur form is computed. Otherwise, the complex Schur form is computed. Then the upper (quasi-)triangular algorithm in [AHR13] is used on the upper (quasi-)triangular factor.\n\n[AH12]: Awad H. Al-Mohy and Nicholas J. Higham, \"Improved inverse  scaling and squaring algorithms for the matrix logarithm\", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. doi:10.1137/110852553\n\n[AHR13]: Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, \"Computing the Fréchet derivative of the matrix logarithm and estimating the condition number\", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. doi:10.1137/120885991\n\nExamples\n\njulia> A = Matrix(2.7182818*I, 2, 2)\n2×2 Matrix{Float64}:\n 2.71828  0.0\n 0.0      2.71828\n\njulia> log(A)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/log/#Complex-Plane","page":"Log","title":"Complex Plane","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/log/","page":"Log","title":"Log","text":"🔗 WikiPedia: https://en.wikipedia.org/wiki/Complexlogarithm#/media/File:Complexlog_domain.svg\n🔗 Sage: https://doc.sagemath.org/html/en/reference/plotting/sage/plot/complex_plot.html#codecell6","category":"page"},{"location":"ElementaryMath/Exp-and-Log/log/","page":"Log","title":"Log","text":"using UnicodePlots\n\nX = repeat(collect(-20:20)', outer=(41, 1));\nY = repeat(collect(20:-1:-20), outer=(1,41));\ngrid = complex.(X, Y) ./ 10;\nZ = log.(grid);\nzangle = angle.(Z);\nheatmap(zangle; xfact=0.1, yfact=0.1, xoffset=-2, yoffset=-2)","category":"page"},{"location":"ElementaryMath/Arithmetic/Transpose/#Transpose","page":"Transpose","title":"Transpose","text":"","category":"section"},{"location":"ElementaryMath/Arithmetic/Transpose/","page":"Transpose","title":"Transpose","text":"Base.adjoint\nBase.transpose","category":"page"},{"location":"ElementaryMath/Arithmetic/Transpose/#Base.adjoint","page":"Transpose","title":"Base.adjoint","text":"A'\nadjoint(A)\n\nLazy adjoint (conjugate transposition). Note that adjoint is applied recursively to elements.\n\nFor number types, adjoint returns the complex conjugate, and therefore it is equivalent to the identity function for real numbers.\n\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims.\n\nExamples\n\njulia> A = [3+2im 9+2im; 0  0]\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 0+0im  0+0im\n\njulia> B = A' # equivalently adjoint(A)\n2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 3-2im  0+0im\n 9-2im  0+0im\n\njulia> B isa Adjoint\ntrue\n\njulia> adjoint(B) === A # the adjoint of an adjoint unwraps the parent\ntrue\n\njulia> Adjoint(B) # however, the constructor always wraps its argument\n2×2 adjoint(adjoint(::Matrix{Complex{Int64}})) with eltype Complex{Int64}:\n 3+2im  9+2im\n 0+0im  0+0im\n\njulia> B[1,2] = 4 + 5im; # modifying B will modify A automatically\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 3+2im  9+2im\n 4-5im  0+0im\n\nFor real matrices, the adjoint operation is equivalent to a transpose.\n\njulia> A = reshape([x for x in 1:4], 2, 2)\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> A'\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  2\n 3  4\n\njulia> adjoint(A) == transpose(A)\ntrue\n\nThe adjoint of an AbstractVector is a row-vector:\n\njulia> x = [3, 4im]\n2-element Vector{Complex{Int64}}:\n 3 + 0im\n 0 + 4im\n\njulia> x'\n1×2 adjoint(::Vector{Complex{Int64}}) with eltype Complex{Int64}:\n 3+0im  0-4im\n\njulia> x'x # compute the dot product, equivalently x' * x\n25 + 0im\n\nFor a matrix of matrices, the individual blocks are recursively operated on:\n\njulia> A = reshape([x + im*x for x in 1:4], 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 1+1im  3+3im\n 2+2im  4+4im\n\njulia> C = reshape([A, 2A, 3A, 4A], 2, 2)\n2×2 Matrix{Matrix{Complex{Int64}}}:\n [1+1im 3+3im; 2+2im 4+4im]  [3+3im 9+9im; 6+6im 12+12im]\n [2+2im 6+6im; 4+4im 8+8im]  [4+4im 12+12im; 8+8im 16+16im]\n\njulia> C'\n2×2 adjoint(::Matrix{Matrix{Complex{Int64}}}) with eltype Adjoint{Complex{Int64}, Matrix{Complex{Int64}}}:\n [1-1im 2-2im; 3-3im 4-4im]    [2-2im 4-4im; 6-6im 8-8im]\n [3-3im 6-6im; 9-9im 12-12im]  [4-4im 8-8im; 12-12im 16-16im]\n\n\n\n\n\nadjoint(F::Factorization)\n\nLazy adjoint of the factorization F. By default, returns an AdjointFactorization wrapper.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Arithmetic/Transpose/#Base.transpose","page":"Transpose","title":"Base.transpose","text":"transpose(A)\n\nLazy transpose. Mutating the returned object should appropriately mutate A. Often, but not always, yields Transpose(A), where Transpose is a lazy transpose wrapper. Note that this operation is recursive.\n\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims, which is non-recursive.\n\nExamples\n\njulia> A = [3 2; 0 0]\n2×2 Matrix{Int64}:\n 3  2\n 0  0\n\njulia> B = transpose(A)\n2×2 transpose(::Matrix{Int64}) with eltype Int64:\n 3  0\n 2  0\n\njulia> B isa Transpose\ntrue\n\njulia> transpose(B) === A # the transpose of a transpose unwraps the parent\ntrue\n\njulia> Transpose(B) # however, the constructor always wraps its argument\n2×2 transpose(transpose(::Matrix{Int64})) with eltype Int64:\n 3  2\n 0  0\n\njulia> B[1,2] = 4; # modifying B will modify A automatically\n\njulia> A\n2×2 Matrix{Int64}:\n 3  2\n 4  0\n\nFor complex matrices, the adjoint operation is equivalent to a conjugate-transpose.\n\njulia> A = reshape([Complex(x, x) for x in 1:4], 2, 2)\n2×2 Matrix{Complex{Int64}}:\n 1+1im  3+3im\n 2+2im  4+4im\n\njulia> adjoint(A) == conj(transpose(A))\ntrue\n\nThe transpose of an AbstractVector is a row-vector:\n\njulia> v = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> transpose(v) # returns a row-vector\n1×3 transpose(::Vector{Int64}) with eltype Int64:\n 1  2  3\n\njulia> transpose(v) * v # compute the dot product\n14\n\nFor a matrix of matrices, the individual blocks are recursively operated on:\n\njulia> C = [1 3; 2 4]\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> D = reshape([C, 2C, 3C, 4C], 2, 2) # construct a block matrix\n2×2 Matrix{Matrix{Int64}}:\n [1 3; 2 4]  [3 9; 6 12]\n [2 6; 4 8]  [4 12; 8 16]\n\njulia> transpose(D) # blocks are recursively transposed\n2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:\n [1 2; 3 4]   [2 4; 6 8]\n [3 6; 9 12]  [4 8; 12 16]\n\n\n\n\n\ntranspose(F::Factorization)\n\nLazy transpose of the factorization F. By default, returns a TransposeFactorization, except for Factorizations with real eltype, in which case returns an AdjointFactorization.\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Exponents-and-Logarithms","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Exponents","page":"Exponents and Logarithms","title":"Exponents","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"exp\nexpm1\nexp2\nexp2m1\nexp10\nexp10m1","category":"page"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Logarithms","page":"Exponents and Logarithms","title":"Logarithms","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"log\nlog1p\nlogp1\nlog2\nlog2p1\nlog10\nlog10p1","category":"page"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Power","page":"Exponents and Logarithms","title":"Power","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"^\npow\nispow2\nprevpow\nnextpow\npowermod","category":"page"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Root","page":"Exponents and Logarithms","title":"Root","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"sqrt\nisqrt\ncbrt","category":"page"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/#Float-Point","page":"Exponents and Logarithms","title":"Float Point","text":"","category":"section"},{"location":"ElementaryMath/Exp-and-Log/exp-and-log/","page":"Exponents and Logarithms","title":"Exponents and Logarithms","text":"exponent\nfrexp\nldexp","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#cos","page":"cos","title":"cos","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"Compute cosine of parameter in radians.","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"using LinearAlgebra","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"Base.cos","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Base.cos","page":"cos","title":"Base.cos","text":"cos(x)\n\nCompute cosine of x, where x is in radians.\n\nSee also cosd, cospi, sincos, cis.\n\n\n\n\n\ncos(A::AbstractMatrix)\n\nCompute the matrix cosine of a square matrix A.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the cosine. Otherwise, the cosine is determined by calling exp.\n\nExamples\n\njulia> cos(fill(1.0, (2,2)))\n2×2 Matrix{Float64}:\n  0.291927  -0.708073\n -0.708073   0.291927\n\n\n\n\n\n","category":"function"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Methods","page":"cos","title":"Methods","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"methods(cos, (Any,), [Base, Base.Math, Base.MathConstants, Base.MPFR])","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Examples","page":"cos","title":"Examples","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"using UnicodePlots\nlineplot(0, 2π, cos)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Real-Numbers","page":"cos","title":"Real Numbers","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"julia> cos(0)\n1.0\n\njulia> cos(0.5*pi)\n6.123233995736766e-17\n\njulia> cos(pi)\n-1.0\n\njulia> pi\nπ = 3.1415926535897...\n\njulia> cos.([0 0.5*pi pi 1.5*pi 2*pi])\n1×5 Matrix{Float64}:\n 1.0  6.12323e-17  -1.0  -1.83697e-16  1.0","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"big float, cos(pi/2) == 0:","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"julia> cos(pi/2)\n6.123233995736766e-17\n\njulia> cos(pi/big\"2\")\n5.48458720489676038371065313197849010525379118254343975589502858496071344256677e-78","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Complex","page":"cos","title":"Complex","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"julia> cos(0+0im)\n1.0 - 0.0im","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"plot real part","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"using UnicodePlots\ncos_real(x, y) = real(cos(x + y*im))\nsurfaceplot(-2pi:0.01:2pi, -pi:0.01:pi, cos_real)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Tips","page":"cos","title":"Tips","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"Call cospi to compute cos(x*pi)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#See-Also","page":"cos","title":"See Also","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"cospi, sincos, cosd, cosh, acos","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Extended-Inputs","page":"cos","title":"Extended Inputs","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Matrix","page":"cos","title":"Matrix","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"With Array like input:","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"methods(cos, (Any,), [LinearAlgebra])","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"# TODO\nBase.cos(AbstractMatrix)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"julia> cos([1 2; 3 4])\n2×2 Matrix{Float64}:\n  0.855423  -0.110876\n -0.166315   0.689109\n\njulia> cos.([1 2; 3 4])\n2×2 Matrix{Float64}:\n  0.540302  -0.416147\n -0.989992  -0.653644\n\njulia> cos([1 2; 3 4]) == cos.([1 2; 3 4])\nfalse","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Tech-Notes","page":"cos","title":"Tech Notes","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"cos(::Real): by pure julia\ncos(::BigFloat): by MPFR","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#Version-History","page":"cos","title":"Version History","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"Introduced in 2018 (1.0)","category":"page"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/#External-Links","page":"cos","title":"External Links","text":"","category":"section"},{"location":"ElementaryMath/Trigonometry/Cosine/cos/","page":"cos","title":"cos","text":"🔗Cosine - Wikipedia\n🔗Cosine - MathWorld","category":"page"}]
}
